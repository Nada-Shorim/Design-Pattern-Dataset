DP Label,Cat Label,Desc,,,,,,,,
0,0,Abstract Factory,,,,,,,,
0,0,Creational,,,,,,,,
0,0,Provide an interface for creating families of related or dependent objects without specifying their concrete classes.,,,,,,,,
0,0,Kit,,,,,,,,
0,0,"Consider a user interface toolkit that supports multiple look-and-feel standards, such as Motif and Presentation Manager. Different look-and-feels define different appearances and behaviors for user interface ""widgets"" like scroll bars, windows, and buttons. To be portable across look-and-feel standards, an application should not hard-code its widgets for a particular look and feel. Instantiating look-and-feel-specific classes of widgets throughout the application makes it hard to change the look and feel later. We can solve this problem by defining an abstract WidgetFactory class that declares an interface for creating each basic kind of widget. There's also an abstract class for each kind of widget, and concrete subclasses implement widgets for specific look-and-feel standards. WidgetFactory's interface has an operation that returns a new widget object for each abstract widget class. Clients call these operations to obtain widget instances, but clients aren't aware of the concrete classes they're using. Thus clients stay independent of the prevailing look and feel. There is a concrete subclass of WidgetFactory for each look-and-feel standard.
Each subclass implements the operations to create the appropriate widget for the
look and feel. For example, the CreateScrollBar operation on the
MotifWidgetFactory instantiates and returns a Motif scroll bar, while the
corresponding operation on the PMWidgetFactory returns a scroll bar for
Presentation Manager. Clients create widgets solely through the WidgetFactory
interface and have no knowledge of the classes that implement widgets for a
particular look and feel. In other words, clients only have to commit to an interface
defined by an abstract class, not a particular concrete class.
A WidgetFactory also enforces dependencies between the concrete widget classes.
A Motif scroll bar should be used with a Motif button and a Motif text editor,
and that constraint is enforced automatically as a consequence of using a
MotifWidgetFactory. ",,,,,,,,
0,0,"a system should be independent of how its products are created, composed,
and represented.
· a system should be configured with one of multiple families of products.
· a family of related product objects is designed to be used together, and
you need to enforce this constraint.
· you want to provide a class library of products, and you want to reveal
just their interfaces, not their implementations. ",,,,,,,,
0,0,"AbstractFactory (WidgetFactory) o declares an interface for operations that create abstract product objects. · ConcreteFactory (MotifWidgetFactory, PMWidgetFactory) o implements the operations to create concrete product objects. · AbstractProduct (Window, ScrollBar) o declares an interface for a type of product object. · ConcreteProduct (MotifWindow, MotifScrollBar) o defines a product object to be created by the corresponding concrete factory. o implements the AbstractProduct interface. · Client o uses only interfaces declared by AbstractFactory and AbstractProduct classes.",,,,,,,,
0,0,"Normally a single instance of a ConcreteFactory class is created at run-time. This concrete factory creates product objects having a particular implementation. To create different product objects, clients should use a different concrete factory. · AbstractFactory defers creation of product objects to its ConcreteFactory subclass.",,,,,,,,
0,0,"InterViews uses the ""Kit"" suffix to denote AbstractFactory classes. It defines WidgetKit and DialogKit abstract factories for generating look-and-feel-specific user interface objects. InterViews also includes a LayoutKit that generates different composition objects depending on the layout desired. For example, a layout that is conceptually horizontal may require
different composition objects depending on the document's orientation (portrait
or landscape).
ET++ uses the Abstract Factory pattern to achieve portability across
different window systems (X Windows and SunView, for example). The WindowSystem
abstract base class defines the interface for creating objects that represent
window system resources (MakeWindow, MakeFont, MakeColor, for example). Concrete
subclasses implement the interfaces for a specific window system. At run-time,
ET++ creates an instance of a concrete WindowSystem subclass that creates concrete
system resource objects. ",,,,,,,,
0,0,Use when you want to create families of related objects without specifying their concrete classes.,,,,,,,,
0,0,Provides an interface for creating families of related or dependent objects without specifying their concrete classes.,,,,,,,,
0,0,The Abstract Factory pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.,,,,,,,,
0,0,"It allows for the creation of objects that are part of a specific family or group, ensuring that the objects created are compatible and cohesive.",,,,,,,,
0,0,Use when you want to provide an interface for creating families of related objects without specifying their concrete classes.,,,,,,,,
0,0,Provides an interface for creating families of related or dependent objects without specifying their concrete classes.,,,,,,,,
0,0,"Use when you want to create objects that are part of a specific family or group, ensuring that the objects created are compatible and cohesive.",,,,,,,,
1,0,Builder,,,,,,,,
1,0,Creational,,,,,,,,
1,0,Separate the construction of a complex object from its representation so that the same construction process can create different representations.,,,,,,,,
1,0,"A reader for the RTF (Rich Text Format) document exchange format should be able to convert RTF to many text formats. The reader might convert RTF documents into plain ASCII text or into a text widget that can be edited interactively. The problem, however, is that the number of possible conversions is open-ended. So it should be easy to add a new conversion without modifying the reader. A solution is to configure the RTFReader class with a TextConverter object that converts RTF to another textual representation. As the RTFReader parses the RTF document, it uses the TextConverter to perform the conversion. Whenever the RTFReader recognizes an RTF token (either plain text or an RTF control word), it issues a request to the TextConverter to convert the token. TextConverter objects are responsible both for performing the data conversion and for representing the token in a particular format. Subclasses of TextConverter specialize in different conversions and formats. For example, an ASCIIConverter ignores requests to convert anything except plain text. A TeXConverter, on the other hand, will implement operations for all requests in order to produce a TeX representation that captures all the stylistic information in the text. A TextWidgetConverter will produce a complex user interface object that lets the user see and edit the text. Each kind of converter class takes the mechanism for creating and assembling a
complex object and puts it behind an abstract interface. The converter is separate
from the reader, which is responsible for parsing an RTF document.
The Builder pattern captures all these relationships. Each converter class is
called a builder in the pattern, and the reader is called the director. Applied
to this example, the Builder pattern separates the algorithm for interpreting
a textual format (that is, the parser for RTF documents) from how a converted
format gets created and represented. This lets us reuse the RTFReader's parsing
algorithm to create different text representations from RTF documents—just
configure the RTFReader with different subclasses of TextConverter. ",,,,,,,,
1,0,the algorithm for creating a complex object should be independent of the parts that make up the object and how they're assembled. · the construction process must allow different representations for the object that's constructed.,,,,,,,,
1,0,"Builder (TextConverter) o specifies an abstract interface for creating parts of a Product object. · ConcreteBuilder (ASCIIConverter, TeXConverter, TextWidgetConverter) o constructs and assembles parts of the product by implementing the Builder interface. o defines and keeps track of the representation it creates. o provides an interface for retrieving the product (e.g., GetASCIIText, GetTextWidget). · Director (RTFReader) o constructs an object using the Builder interface. · Product (ASCIIText, TeXText, TextWidget) o represents the complex object under construction. ConcreteBuilder builds the product's internal representation and defines the process by which it's assembled. o includes classes that define the constituent parts, including interfaces for assembling the parts into the final result.",,,,,,,,
1,0,The client creates the Director object and configures it with the desired Builder object. · Director notifies the builder whenever a part of the product should be built. · Builder handles requests from the director and adds parts to the product. · The client retrieves the product from the builder.,,,,,,,,
1,0,"The RTF converter application is from ET++. Its text building block uses
a builder to process text stored in the RTF format.
Builder is a common pattern in Smalltalk-80:
· The Parser class in the compiler subsystem is a Director that takes a
ProgramNodeBuilder object as an argument. A Parser object notifies its
ProgramNodeBuilder object each time it recognizes a syntactic construct.
When the parser is done, it asks the builder for the parse tree it built
and returns it to the client.· ClassBuilder is a builder that Classes use to create subclasses for
themselves. In this case a Class is both the Director and the Product.
· ByteCodeStream is a builder that creates a compiled method as a byte array.
ByteCodeStream is a nonstandard use of the Builder pattern, because the
complex object it builds is encoded as a byte array, not as a normal Smalltalk
object. But the interface to ByteCodeStream is typical of a builder, and
it would be easy to replace ByteCodeStream with a different class that
represented programs as a composite object.
The Service Configurator framework from the Adaptive Communications Environment
uses a builder to construct network service components that are linked into a
server at run-time. The components are described with a configuration
language that's parsed by an LALR(1) parser. The semantic actions of the parser
perform operations on the builder that add information to the service component.
In this case, the parser is the Director. ",,,,,,,,
1,0,"Use when you want to construct complex objects step by step, providing a flexible approach to object creation.",,,,,,,,
1,0,"The Builder pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations.",,,,,,,,
1,0,"It provides a step-by-step approach to create objects, allowing for the creation of complex objects with varying configurations.",,,,,,,,
1,0,Use when you want to separate the construction of a complex object from its representation and have a step-by-step approach to create objects.,,,,,,,,
1,0,"Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.",,,,,,,,
1,0,"Use when you want to create complex objects step by step, providing a flexible approach to object creation.",,,,,,,,
2,0,Factory Method,,,,,,,,
2,0,Creational,,,,,,,,
2,0,"Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.",,,,,,,,
2,0,Virtual Constructor,,,,,,,,
2,0,"Frameworks use abstract classes to define and maintain relationships between
objects. A framework is often responsible for creating these objects as well.
Consider a framework for applications that can present multiple documents to the
user. Two key abstractions in this framework are the classes Application and
Document. Both classes are abstract, and clients have to subclass them to realize
their application-specific implementations. To create a drawing application, for
example, we define the classes DrawingApplication and DrawingDocument. The
Application class is responsible for managing Documents and will create them as
required—when the user selects Open or New from a menu, for example.
Because the particular Document subclass to instantiate is application-specific,
the Application class can't predict the subclass of Document to instantiate—the
Application class only knows when a new document should be created, not what kind
of Document to create. This creates a dilemma: The framework must instantiate
classes, but it only knows about abstract classes, which it cannot instantiate.
The Factory Method pattern offers a solution. It encapsulates the knowledge of
which Document subclass to create and moves this knowledge out of the framework. Application subclasses redefine an abstract CreateDocument operation on
Application to return the appropriate Document subclass. Once an Application
subclass is instantiated, it can then instantiate application-specific Documents
without knowing their class. We call CreateDocument a factory method because it's
responsible for ""manufacturing"" an object. ",,,,,,,,
2,0,"· a class can't anticipate the class of objects it must create.
· a class wants its subclasses to specify the objects it creates.
· classes delegate responsibility to one of several helper subclasses, and
you want to localize the knowledge of which helper subclass is the delegate.",,,,,,,,
2,0,"· Product (Document)
o defines the interface of objects the factory method creates.
· ConcreteProduct (MyDocument)
o implements the Product interface.
· Creator (Application)
o declares the factory method, which returns an object of type Product.
Creator may also define a default implementation of the factory
method that returns a default ConcreteProduct object.
o may call the factory method to create a Product object.
· ConcreteCreator (MyApplication)
o overrides the factory method to return an instance of a
ConcreteProduct. ",,,,,,,,
2,0,Creator relies on its subclasses to define the factory method so that it returns an instance of the appropriate ConcreteProduct.,,,,,,,,
2,0,"Factory methods pervade toolkits and frameworks. The preceding document example
is a typical use in MacApp and ET++. The manipulator example is from Unidraw.
Class View in the Smalltalk-80 Model/View/Controller framework has a method
defaultController that creates a controller, and this might appear to be a factory
method. But subclasses of View specify the class of their default
controller by defining defaultControllerClass, which returns the class from which
defaultController creates instances. So defaultControllerClass is the real
factory method, that is, the method that subclasses should override.
A more esoteric example in Smalltalk-80 is the factory method parserClass defined
by Behavior (a superclass of all objects representing classes). This enables a
class to use a customized parser for its source code. For example, a client can
define a class SQLParser to analyze the source code of a class with embedded SQL
statements. The Behavior class implements parserClass to return the standard
Smalltalk Parser class. A class that includes embedded SQL statements overrides
this method (as a class method) and returns the SQLParser class.
The Orbix ORB system from IONA Technologies uses Factory Method to generate
an appropriate type of proxy) when an object requests a reference
to a remote object. Factory Method makes it easy to replace the default proxy
with one that uses client-side caching, for example. ",,,,,,,,
2,0,"Use when you want to delegate the object creation to subclasses, allowing flexibility in choosing the concrete class.",,,,,,,,
2,0,"Defines an interface for creating objects, but lets subclasses decide which class to instantiate.",,,,,,,,
2,0,"The Factory Method pattern provides an interface for creating objects, but lets subclasses decide which class to instantiate.",,,,,,,,
2,0,"It allows for the creation of objects without specifying the exact class, promoting loose coupling and flexibility in object creation.
",,,,,,,,
2,0,"Use when you want to provide an interface for creating objects, but let subclasses decide which class to instantiate.",,,,,,,,
2,0,"Provides an interface for creating objects, but lets subclasses decide which class to instantiate.",,,,,,,,
2,0,"Use when you want to provide a common interface for creating objects, but allow subclasses to determine the concrete class to instantiate.",,,,,,,,
3,0,Prototype,,,,,,,,
3,0,Creational,,,,,,,,
3,0,"Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.",,,,,,,,
3,0,"You could build an editor for music scores by customizing a general framework
for graphical editors and adding new objects that represent notes, rests, and
staves. The editor framework may have a palette of tools for adding these music
objects to the score. The palette would also include tools for selecting, moving,
and otherwise manipulating music objects. Users will click on the quarter-note
tool and use it to add quarter notes to the score. Or they can use the move tool
to move a note up or down on the staff, thereby changing its pitch.
Let's assume the framework provides an abstract Graphic class for graphical
components, like notes and staves. Moreover, it'll provide an abstract Tool class
for defining tools like those in the palette. The framework also predefines a
GraphicTool subclass for tools that create instances of graphical objects and
add them to the document.
But GraphicTool presents a problem to the framework designer. The classes for
notes and staves are specific to our application, but the GraphicTool class belongs
to the framework. GraphicTool doesn't know how to create instances of our music
classes to add to the score. We could subclass GraphicTool for each kind of music
object, but that would produce lots of subclasses that differ only in the kind
of music object they instantiate. We know object composition is a flexible
alternative to subclassing. The question is, how can the framework use it to
parameterize instances of GraphicTool by the class of Graphic they're supposed
to create?
The solution lies in making GraphicTool create a new Graphic by copying or ""cloning""
an instance of a Graphic subclass. We call this instance a prototype. GraphicTool
is parameterized by the prototype it should clone and add to the document. If
all Graphic subclasses support a Clone operation, then the GraphicTool can clone
any kind of Graphic.
So in our music editor, each tool for creating a music object is an instance of
GraphicTool that's initialized with a different prototype. Each GraphicTool instance will produce a music object by cloning its prototype and adding the clone
to the score.  We can use the Prototype pattern to reduce the number of classes even further.
We have separate classes for whole notes and half notes, but that's probably
unnecessary. Instead they could be instances of the same class initialized with
different bitmaps and durations. A tool for creating whole notes becomes just
a GraphicTool whose prototype is a MusicalNote initialized to be a whole note.
This can reduce the number of classes in the system dramatically. It also makes
it easier to add a new kind of note to the music editor. ",,,,,,,,
3,0,"Use the Prototype pattern when a system should be independent of how its products
are created, composed, and represented; and
· when the classes to instantiate are specified at run-time, for example,
by dynamic loading; or
· to avoid building a class hierarchy of factories that parallels the class
hierarchy of products; or
· when instances of a class can have one of only a few different combinations
of state. It may be more convenient to install a corresponding number of
prototypes and clone them rather than instantiating the class manually,
each time with the appropriate state. ",,,,,,,,
3,0,"· Prototype (Graphic)
o declares an interface for cloning itself.
· ConcretePrototype (Staff, WholeNote, HalfNote)
o implements an operation for cloning itself.
· Client (GraphicTool)
o creates a new object by asking a prototype to clone itself. ",,,,,,,,
3,0,A client asks a prototype to clone itself.,,,,,,,,
3,0,"Perhaps the first example of the Prototype pattern was in Ivan Sutherland's
Sketchpad system. The first widely known application of the pattern in
an object-oriented language was in ThingLab, where users could form a composite object and then promote it to a prototype by installing it in a library of reusable
objects. Goldberg and Robson mention prototypes as a pattern, but
Coplien gives a much more complete description. He describes idioms related
to the Prototype pattern for C++ and gives many examples and variations.
Etgdb is a debugger front-end based on ET++ that provides a point-and-click
interface to different line-oriented debuggers. Each debugger has a corresponding
DebuggerAdaptor subclass. For example, GdbAdaptor adapts etgdb to the command
syntax of GNU gdb, while SunDbxAdaptor adapts etgdb to Sun's dbx debugger. Etgdb
does not have a set of DebuggerAdaptor classes hard-coded into it. Instead, it
reads the name of the adaptor to use from an environment variable, looks for a
prototype with the specified name in a global table, and then clones the prototype.
New debuggers can be added to etgdb by linking it with the DebuggerAdaptor that
works for that debugger.
The ""interaction technique library"" in Mode Composer stores prototypes of objects
that support various interaction techniques. Any interaction technique
created by the Mode Composer can be used as a prototype by placing it in this
library. The Prototype pattern lets Mode Composer support an unlimited set of
interaction techniques.
The music editor example discussed earlier is based on the Unidraw drawing
framework. ",,,,,,,,
3,0,"Use when you want to create new objects by copying or cloning existing objects, avoiding the cost of creating objects from scratch.",,,,,,,,
3,0,The Prototype pattern allows for the creation of new objects by cloning or copying existing objects.,,,,,,,,
3,0,"It is useful when creating new objects is costly or complex, and you want to create new instances by copying existing objects.",,,,,,,,
3,0,"Use when creating new objects is costly or complex, and you want to create new instances by cloning or copying existing objects.",,,,,,,,
3,0,Allows for the creation of new objects by cloning or copying existing objects.,,,,,,,,
3,0,"Use when creating new objects is costly or complex, and you want to create new instances by copying existing objects.",,,,,,,,
4,0,Singleton,,,,,,,,
4,0,Creational,,,,,,,,
4,0,"Ensure a class only has one instance, and provide a global point of access to it.",,,,,,,,
4,0,"It's important for some classes to have exactly one instance. Although there can be many printers in a system, there should be only one printer spooler. There should be only one file system and one window manager. A digital filter will have one A/D converter. An accounting system will be dedicated to serving one company. How do we ensure that a class has only one instance and that the instance is easily accessible? A global variable makes an object accessible, but it doesn't keep you from instantiating multiple objects. A better solution is to make the class itself responsible for keeping track of its sole instance. The class can ensure that no other instance can be created (by intercepting requests to create new objects), and it can provide a way to access the instance. This is the Singleton pattern.",,,,,,,,
4,0,"there must be exactly one instance of a class, and it must be accessible to clients from a well-known access point. · when the sole instance should be extensible by subclassing, and clients should be able to use an extended instance without modifying their code.",,,,,,,,
4,0,"· Singleton o defines an Instance operation that lets clients access its unique instance. Instance is a class operation (that is, a class method in Smalltalk and a static member function in C++). o may be responsible for creating its own unique instance.",,,,,,,,
4,0,Clients access a Singleton instance solely through Singleton's Instance operation,,,,,,,,
4,0,"An example of the Singleton pattern in Smalltalk-80 is the set of changes
to the code, which is ChangeSet current. A more subtle example is the relationship
between classes and their metaclasses. A metaclass is the class of a class, and
each metaclass has one instance. Metaclasses do not have names (except indirectly through their sole instance), but they keep track of their sole instance and will
not normally create another.
The InterViews user interface toolkit uses the Singleton pattern to access
the unique instance of its Session and WidgetKit classes, among others. Session
defines the application's main event dispatch loop, stores the user's database
of stylistic preferences, and manages connections to one or more physical displays.
WidgetKit is an Abstract Factory (99) for defining the look and feel of user
interface widgets. The WidgetKit::instance() operation determines the particular
WidgetKit subclass that's instantiated based on an environment variable that
Session defines. A similar operation on Session determines whether monochrome
or color displays are supported and configures the singleton Session instance
accordingly. ",,,,,,,,
4,0,Use when you want to ensure only one instance of a class is created and provide a global access point to it.,,,,,,,,
4,0,Ensures a class has only one instance and provides a global point of access to it.,,,,,,,,
4,0,The Singleton pattern ensures that only one instance of a class is created and provides a global point of access to it.,,,,,,,,
4,0,It is useful when you want to restrict object creation to a single instance and ensure that all clients access the same instance.,,,,,,,,
4,0,Use when you want to restrict object creation to a single instance and provide a global point of access to that instance.,,,,,,,,
4,0,Ensures that only one instance of a class is created and provides a global access point to it.,,,,,,,,
4,0,Use when you want to restrict object creation to a single instance and ensure that all clients access the same instance.,,,,,,,,
5,1,Adapter,,,,,,,,
5,1,Structural,,,,,,,,
5,1,Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.,,,,,,,,
5,1,Wrapper,,,,,,,,
5,1,"Sometimes a toolkit class that's designed for reuse isn't reusable only because its interface doesn't match the domain-specific interface an application requires. Consider for example a drawing editor that lets users draw and arrange graphical elements (lines, polygons, text, etc.) into pictures and diagrams. The drawing editor's key abstraction is the graphical object, which has an editable shape and can draw itself. The interface for graphical objects is defined by an abstract class called Shape. The editor defines a subclass of Shape for each kind of graphical object: a LineShape class for lines, a PolygonShape class for polygons, and so forth. Classes for elementary geometric shapes like LineShape and PolygonShape are rather easy to implement, because their drawing and editing capabilities are inherently limited. But a TextShape subclass that can display and edit text is considerably more difficult to implement, since even basic text editing involves complicated screen update and buffer management. Meanwhile, an off-the-shelf user interface toolkit might already provide a sophisticated TextView class for displaying and editing text. Ideally we'd like to reuse TextView to implement TextShape, but the toolkit wasn't designed with Shape classes in mind. So we can't use TextView and Shape objects interchangeably. How can existing and unrelated classes like TextView work in an application that expects classes with a different and incompatible interface? We could change the TextView class so that it conforms to the Shape interface, but that isn't an option unless we have the toolkit's source code. Even if we did, it wouldn't make sense to change TextView; the toolkit shouldn't have to adopt domain-specific interfaces just to make one application work. Instead, we could define TextShape so that it adapts the TextView interface to
Shape's. We can do this in one of two ways: (1) by inheriting Shape's interface
and TextView's implementation or (2) by composing a TextView instance within a
TextShape and implementing TextShape in terms of TextView's interface. These two
approaches correspond to the class and object versions of the Adapter pattern.
We call TextShape an adapter.  This diagram illustrates the object adapter case. It shows how BoundingBox requests,
declared in class Shape, are converted to GetExtent requests defined in TextView.
Since TextShape adapts TextView to the Shape interface, the drawing editor can
reuse the otherwise incompatible TextView class.
Often the adapter is responsible for functionality the adapted class doesn't
provide. The diagram shows how an adapter can fulfill such responsibilities. The
user should be able to ""drag"" every Shape object to a new location interactively,
but TextView isn't designed to do that. TextShape can add this missing
functionality by implementing Shape's CreateManipulator operation, which returns
an instance of the appropriate Manipulator subclass.
Manipulator is an abstract class for objects that know how to animate a Shape
in response to user input, like dragging the shape to a new location. There are
subclasses of Manipulator for different shapes; TextManipulator, for example,
is the corresponding subclass for TextShape. By returning a TextManipulator
instance, TextShape adds the functionality that TextView lacks but Shape requires. ",,,,,,,,
5,1,"you want to use an existing class, and its interface does not match the one you need.you want to create a reusable class that cooperates with unrelated or
unforeseen classes, that is, classes that don't necessarily have compatible
interfaces.
· (object adapter only) you need to use several existing subclasses, but it's
impractical to adapt their interface by subclassing every one. An object
adapter can adapt the interface of its parent class.",,,,,,,,
5,1,"· Target (Shape) o defines the domain-specific interface that Client uses. · Client (DrawingEditor) o collaborates with objects conforming to the Target interface. · Adaptee (TextView) o defines an existing interface that needs adapting.
· Adapter (TextShape)
o adapts the interface of Adaptee to the Target interface. ",,,,,,,,
5,1,"Clients call operations on an Adapter instance. In turn, the adapter calls Adaptee operations that carry out the request.",,,,,,,,
5,1,"The Motivation example comes from ET++Draw, a drawing application based on ET++. ET++Draw reuses the ET++ classes for text editing by using a TextShape
adapter class.
InterViews 2.6 defines an Interactor abstract class for user interface elements
such as scroll bars, buttons, and menus. It also defines a Graphic abstract
class for structured graphic objects such as lines, circles, polygons, and splines.
Both Interactors and Graphics have graphical appearances, but they have different
interfaces and implementations (they share no common parent class) and are
therefore incompatible—you can't embed a structured graphic object in, say, a
dialog box directly.
Instead, InterViews 2.6 defines an object adapter called GraphicBlock, a subclass
of Interactor that contains a Graphic instance. The GraphicBlock adapts the
interface of the Graphic class to that of Interactor. The GraphicBlock lets a
Graphic instance be displayed, scrolled, and zoomed within an Interactor
structure.
Pluggable adapters are common in ObjectWorks\Smalltalk. Standard
Smalltalk defines a ValueModel class for views that display a single value.
ValueModel defines a value, value: interface for accessing the value. These are
abstract methods. Application writers access the value with more domain-specific
names like width and width:, but they shouldn't have to subclass ValueModel to
adapt such application-specific names to the ValueModel interface.
Instead, ObjectWorks\Smalltalk includes a subclass of ValueModel called
PluggableAdaptor. A PluggableAdaptor object adapts other objects to the ValueModel
interface (value, value:). It can be parameterized with blocks for getting and
setting the desired value. PluggableAdaptor uses these blocks internally to
implement the value, value: interface. PluggableAdaptor also lets you pass in
the selector names (e.g., width, width:) directly for syntactic convenience. It
converts these selectors into the corresponding blocks automatically.
Another example from ObjectWorks\Smalltalk is the TableAdaptor class. A
TableAdaptor can adapt a sequence of objects to a tabular presentation. The table
displays one object per row. The client parameterizes TableAdaptor with the set
of messages that a table can use to get the column values from an object.
Some classes in NeXT's AppKit use delegate objects to perform interface
adaptation. An example is the NXBrowser class that can display hierarchical lists
of data. NXBrowser uses a delegate object for accessing and adapting the data.
Meyer's ""Marriage of Convenience"" is a form of class adapter. Meyer
describes how a FixedStack class adapts the implementation of an Array class to
the interface of a Stack class. The result is a stack containing a fixed number
of entries.",,,,,,,,
5,1,Use when you want to convert the interface of a class into another interface that clients expect.,,,,,,,,
5,1,"Converts the interface of a class into another interface that clients expect, allowing classes with incompatible interfaces to work together.",,,,,,,,
5,1,"The Adapter pattern converts the interface of a class into another interface that clients expect, allowing classes with incompatible interfaces to work together.",,,,,,,,
5,1,"It acts as a bridge between two incompatible interfaces, enabling them to collaborate without needing to modify their existing code.",,,,,,,,
5,1,Use when you have classes with incompatible interfaces and need to make them work together by converting one interface into another.,,,,,,,,
5,1,Converts the interface of a class into another interface that clients expect.,,,,,,,,
5,1,"Use when you have classes with incompatible interfaces and need to make them work together by converting one interface into another.
",,,,,,,,
6,1,Bridge,,,,,,,,
6,1,Structural,,,,,,,,
6,1,"Decouple an abstraction from its implementation so that the two can vary
independently. ",,,,,,,,
6,1,Handle/Body,,,,,,,,
6,1,"When an abstraction can have one of several possible implementations, the usual
way to accommodate them is to use inheritance. An abstract class defines the
interface to the abstraction, and concrete subclasses implement it in different
ways. But this approach isn't always flexible enough. Inheritance binds an
implementation to the abstraction permanently, which makes it difficult to modify,
extend, and reuse abstractions and implementations independently.
Consider the implementation of a portable Window abstraction in a user interface
toolkit. This abstraction should enable us to write applications that work on
both the X Window System and IBM's Presentation Manager (PM), for example. Using
inheritance, we could define an abstract class Window and subclasses XWindow and
PMWindow that implement the Window interface for the different platforms. But
this approach has two drawbacks:
1. It's inconvenient to extend the Window abstraction to cover different kinds
of windows or new platforms. Imagine an IconWindow subclass of Window that
specializes the Window abstraction for icons. To support IconWindows for
both platforms, we have to implement two new classes, XIconWindow and
PMIconWindow. Worse, we'll have to define two classes for every kind of
window. Supporting a third platform requires yet another new Window subclass
for every kind of window. 
2. It makes client code platform-dependent. Whenever a client creates a window,
it instantiates a concrete class that has a specific implementation. For
example, creating an XWindow object binds the Window abstraction to the
X Window implementation, which makes the client code dependent on the X
Window implementation. This, in turn, makes it harder to port the client
code to other platforms.
Clients should be able to create a window without committing to a concrete
implementation. Only the window implementation should depend on the
platform on which the application runs. Therefore client code should
instantiate windows without mentioning specific platforms.
The Bridge pattern addresses these problems by putting the Window abstraction
and its implementation in separate class hierarchies. There is one class hierarchy
for window interfaces (Window, IconWindow, TransientWindow) and a separate
hierarchy for platform-specific window implementations, with WindowImp as its
root. The XWindowImp subclass, for example, provides an implementation based on
the X Window System. 
All operations on Window subclasses are implemented in terms of abstract operations
from the WindowImp interface. This decouples the window abstractions from the
various platform-specific implementations. We refer to the relationship between
Window and WindowImp as a bridge, because it bridges the abstraction and its
implementation, letting them vary independently.",,,,,,,,
6,1,"· you want to avoid a permanent binding between an abstraction and its implementation. This might be the case, for example, when the implementation must be selected or switched at run-time. · both the abstractions and their implementations should be extensible by subclassing. In this case, the Bridge pattern lets you combine the different abstractions and implementations and extend them independently. · changes in the implementation of an abstraction should have no impact on clients; that is, their code should not have to be recompiled. · (C++) you want to hide the implementation of an abstraction completely from clients. In C++ the representation of a class is visible in the class interface. · you have a proliferation of classes as shown earlier in the first Motivation diagram. Such a class hierarchy indicates the need for splitting an object into two parts. Rumbaugh uses the term ""nested generalizations""
to refer to such class hierarchies.
· you want to share an implementation among multiple objects (perhaps using
reference counting), and this fact should be hidden from the client. A simple
example is Coplien's String class, in which multiple objects can
share the same string representation (StringRep).",,,,,,,,
6,1,"· Abstraction (Window)
o defines the abstraction's interface.
o maintains a reference to an object of type Implementor.
· RefinedAbstraction (IconWindow)
o Extends the interface defined by Abstraction.
· Implementor (WindowImp)
o defines the interface for implementation classes. This interface
doesn't have to correspond exactly to Abstraction's interface; in
fact the two interfaces can be quite different. Typically the
Implementor interface provides only primitive operations, and
Abstraction defines higher-level operations based on these
primitives.
· ConcreteImplementor (XWindowImp, PMWindowImp)
o implements the Implementor interface and defines its concrete
implementation. ",,,,,,,,
6,1,Abstraction forwards client requests to its Implementor object.,,,,,,,,
6,1,"The Window example above comes from ET++. In ET++, WindowImp is called
""WindowPort"" and has subclasses such as XWindowPort and SunWindowPort. The Window
object creates its corresponding Implementor object by requesting it from an
abstract factory called ""WindowSystem."" WindowSystem provides an interface for
creating platform-specific objects such as fonts, cursors, bitmaps, and so forth.
The ET++ Window/WindowPort design extends the Bridge pattern in that the WindowPort
also keeps a reference back to the Window. The WindowPort implementor class uses  this reference to notify Window about WindowPort-specific events: the arrival
of input events, window resizes, etc.
Both Coplien and Stroustrup mention Handle classes and give some
examples. Their examples emphasize memory management issues like sharing string
representations and support for variable-sized objects. Our focus is more on
supporting independent extension of both an abstraction and its implementation.
libg++ defines classes that implement common data structures, such as
Set, LinkedSet, HashSet, LinkedList, and HashTable. Set is an abstract class that
defines a set abstraction, while LinkedList and HashTable are concrete
implementors for a linked list and a hash table, respectively. LinkedSet and
HashSet are Set implementors that bridge between Set and their concrete
counterparts LinkedList and HashTable. This is an example of a degenerate bridge,
because there's no abstract Implementor class.
NeXT's AppKit uses the Bridge pattern in the implementation and display
of graphical images. An image can be represented in several different ways. The
optimal display of an image depends on the properties of a display device,
specifically its color capabilities and its resolution. Without help from AppKit,
developers would have to determine which implementation to use under various
circumstances in every application.
To relieve developers of this responsibility, AppKit provides an
NXImage/NXImageRep bridge. NXImage defines the interface for handling images.
The implementation of images is defined in a separate NXImageRep class hierarchy
having subclasses such as NXEPSImageRep, NXCachedImageRep, and NXBitMapImageRep.
NXImage maintains a reference to one or more NXImageRep objects. If there is more
than one image implementation, then NXImage selects the most appropriate one for
the current display device. NXImage is even capable of converting one
implementation to another if necessary. The interesting aspect of this Bridge
variant is that NXImage can store more than one NXImageRep implementation at a
time. ",,,,,,,,
6,1,"Use when you want to separate the abstraction from its implementation, allowing them to vary independently.",,,,,,,,
6,1,"The Bridge pattern decouples an abstraction from its implementation, allowing them to vary independently.",,,,,,,,
6,1,"It separates the abstraction (high-level functionality) from its implementation (low-level details), enabling them to be modified and extended independently.",,,,,,,,
6,1,Use when you want to separate the abstraction (high-level functionality) from its implementation (low-level details) so that they can vary independently.,,,,,,,,
6,1,Separates the abstraction (high-level functionality) from its implementation (low-level details) so that they can vary independently.,,,,,,,,
6,1,"Use when you want to decouple abstraction from implementation, allowing them to evolve independently.",,,,,,,,
7,1,Composite,,,,,,,,
7,1,Structural,,,,,,,,
7,1,Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.,,,,,,,,
7,1,"Graphics applications like drawing editors and schematic capture systems let users build complex diagrams out of simple components. The user can group components to form larger components, which in turn can be grouped to form still larger components. A simple implementation could define classes for graphical primitives such as Text and Lines plus other classes that act as containers for these primitives. But there's a problem with this approach: Code that uses these classes must treat primitive and container objects differently, even if most of the time the user treats them identically. Having to distinguish these objects makes the application more complex. The Composite pattern describes how to use recursive composition so that clients don't have to make this distinction. The key to the Composite pattern is an abstract class that represents both
primitives and their containers. For the graphics system, this class is Graphic.
Graphic declares operations like Draw that are specific to graphical objects. It also declares operations that all composite objects share, such as operations
for accessing and managing its children.
The subclasses Line, Rectangle, and Text (see preceding class diagram) define
primitive graphical objects. These classes implement Draw to draw lines,
rectangles, and text, respectively. Since primitive graphics have no child
graphics, none of these subclasses implements child-related operations.
The Picture class defines an aggregate of Graphic objects. Picture implements
Draw to call Draw on its children, and it implements child-related operations
accordingly. Because the Picture interface conforms to the Graphic interface,
Picture objects can compose other Pictures recursively.",,,,,,,,
7,1,"· you want to represent part-whole hierarchies of objects.
· you want clients to be able to ignore the difference between compositions
of objects and individual objects. Clients will treat all objects in the
composite structure uniformly. ",,,,,,,,
7,1,"· Component (Graphic)
o declares the interface for objects in the composition.
o implements default behavior for the interface common to all classes,
as appropriate.
o declares an interface for accessing and managing its child
components.
o (optional) defines an interface for accessing a component's parent
in the recursive structure, and implements it if that's appropriate.
· Leaf (Rectangle, Line, Text, etc.)
o represents leaf objects in the composition. A leaf has no children.
o defines behavior for primitive objects in the composition.
· Composite (Picture) 
o defines behavior for components having children.
o stores child components.
o implements child-related operations in the Component interface.
· Client
o manipulates objects in the composition through the Component
interface. ",,,,,,,,
7,1,"Clients use the Component class interface to interact with objects in the
composite structure. If the recipient is a Leaf, then the request is handled
directly. If the recipient is a Composite, then it usually forwards requests
to its child components, possibly performing additional operations before
and/or after forwarding",,,,,,,,
7,1,"Examples of the Composite pattern can be found in almost all object-oriented
systems. The original View class of Smalltalk Model/View/Controller was
a Composite, and nearly every user interface toolkit or framework has followed
in its steps, including ET++ (with its VObjects) and InterViews (Styles, Graphics, and Glyphs). It's interesting to note that the
original View of Model/View/Controller had a set of subviews; in other words,
View was both the Component class and the Composite class. Release 4.0 of
Smalltalk-80 revised Model/View/Controller with a VisualComponent class that has
subclasses View and CompositeView.
The RTL Smalltalk compiler framework uses the Composite pattern
extensively. RTLExpression is a Component class for parse trees. It has subclasses,
such as BinaryExpression, that contain child RTLExpression objects. These classes
define a composite structure for parse trees. RegisterTransfer is the Component
class for a program's intermediate Single Static Assignment (SSA) form. Leaf
subclasses of RegisterTransfer define different static assignments such as
· primitive assignments that perform an operation on two registers and assign
the result to a third;
· an assignment with a source register but no destination register, which
indicates that the register is used after a routine returns; and
· an assignment with a destination register but no source, which indicates
that the register is assigned before the routine starts.
Another subclass, RegisterTransferSet, is a Composite class for representing
assignments that change several registers at once.
Another example of this pattern occurs in the financial domain, where a portfolio
aggregates individual assets. You can support complex aggregations of assets by
implementing a portfolio as a Composite that conforms to the interface of an
individual asset.
The Command (263) pattern describes how Command objects can be composed and
sequenced with a MacroCommand Composite class. ",,,,,,,,
7,1,"Use when you want to treat individual objects and compositions of objects uniformly, forming part-whole hierarchies.",,,,,,,,
7,1,"Composes objects into tree-like structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions uniformly.",,,,,,,,
7,1,The Composite pattern composes objects into tree-like structures to represent part-whole hierarchies.,,,,,,,,
7,1,"It allows clients to treat individual objects and compositions of objects uniformly, simplifying the code and enabling recursive operations on the structure.",,,,,,,,
7,1,Use when you have a part-whole hierarchy of objects and want to treat individual objects and compositions of objects uniformly.,,,,,,,,
7,1,"Treats individual objects and compositions of objects uniformly, forming part-whole hierarchies.",,,,,,,,
7,1,Use when you have a part-whole hierarchy of objects and want to treat individual objects and compositions of objects uniformly.,,,,,,,,
8,1,Decorator,,,,,,,,
8,1,Structural,,,,,,,,
8,1,Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.,,,,,,,,
8,1,Wrapper,,,,,,,,
8,1,"Sometimes we want to add responsibilities to individual objects, not to an entire class. A graphical user interface toolkit, for example, should let you add properties like borders or behaviors like scrolling to any user interface component. One way to add responsibilities is with inheritance. Inheriting a border from another class puts a border around every subclass instance. This is inflexible, however, because the choice of border is made statically. A client can't control how and when to decorate the component with a border. A more flexible approach is to enclose the component in another object that adds the border. The enclosing object is called a decorator. The decorator conforms to the interface of the component it decorates so that its presence is transparent to the component's clients. The decorator forwards requests to the component and may perform additional actions (such as drawing a border) before or after forwarding. Transparency lets you nest decorators recursively, thereby allowing an unlimited number of added responsibilities. For example, suppose we have a TextView object that displays text in a window.
TextView has no scroll bars by default, because we might not always need them.
When we do, we can use a ScrollDecorator to add them. Suppose we also want to
add a thick black border around the TextView. We can use a BorderDecorator to
add this as well. We simply compose the decorators with the TextView to produce
the desired result. The ScrollDecorator and BorderDecorator classes are subclasses of Decorator, an
abstract class for visual components that decorate other visual components. VisualComponent is the abstract class for visual objects. It defines their drawing
and event handling interface. Note how the Decorator class simply forwards draw
requests to its component, and how Decorator subclasses can extend this operation.
Decorator subclasses are free to add operations for specific functionality. For
example, ScrollDecorator's ScrollTo operation lets other objects scroll the
interface if they know there happens to be a ScrollDecorator object in the interface.
The important aspect of this pattern is that it lets decorators appear anywhere
a VisualComponent can. That way clients generally can't tell the difference between
a decorated component and an undecorated one, and so they don't depend at all
on the decoration. ",,,,,,,,
8,1,"to add responsibilities to individual objects dynamically and transparently, that is, without affecting other objects. · for responsibilities that can be withdrawn. · when extension by subclassing is impractical. Sometimes a large number of independent extensions are possible and would produce an explosion of subclasses to support every combination. Or a class definition may be hidden or otherwise unavailable for subclassing.",,,,,,,,
8,1,"· Component (VisualComponent) o defines the interface for objects that can have responsibilities added to them dynamically. · ConcreteComponent (TextView) o defines an object to which additional responsibilities can be attached. · Decorator o maintains a reference to a Component object and defines an interface that conforms to Component's interface. · ConcreteDecorator (BorderDecorator, ScrollDecorator) o adds responsibilities to the component.",,,,,,,,
8,1,Decorator forwards requests to its Component object. It may optionally perform additional operations before and after forwarding the request.,,,,,,,,
8,1,"Many object-oriented user interface toolkits use decorators to add graphical
embellishments to widgets. Examples include InterViews, ET++, and the ObjectWorks\Smalltalk class library. More exotic
applications of Decorator are the DebuggingGlyph from InterViews and the
PassivityWrapper from ParcPlace Smalltalk. A DebuggingGlyph prints out debugging
information before and after it forwards a layout request to its component. This
trace information can be used to analyze and debug the layout behavior of objects
in a complex composition. The PassivityWrapper can enable or disable user
interactions with the component.
But the Decorator pattern is by no means limited to graphical user interfaces,
as the following example (based on the ET++ streaming classes) illustrates.
Streams are a fundamental abstraction in most I/O facilities. A stream can provide
an interface for converting objects into a sequence of bytes or characters. That
lets us transcribe an object to a file or to a string in memory for retrieval
later. A straightforward way to do this is to define an abstract Stream class
with subclasses MemoryStream and FileStream. But suppose we also want to be able
to do the following:
· Compress the stream data using different compression algorithms
(run-length encoding, Lempel-Ziv, etc.).
· Reduce the stream data to 7-bit ASCII characters so that it can be
transmitted over an ASCII communication channel.
The Decorator pattern gives us an elegant way to add these responsibilities to
streams. The diagram below shows one solution to the problem: The Stream abstract class maintains an internal buffer and provides operations
for storing data onto the stream (PutInt, PutString). Whenever the buffer is full,
Stream calls the abstract operation HandleBufferFull, which does the actual data
transfer. The FileStream version of this operation overrides this operation to
transfer the buffer to a file.
The key class here is StreamDecorator, which maintains a reference to a component
stream and forwards requests to it. StreamDecorator subclasses override
HandleBufferFull and perform additional actions before calling StreamDecorator's
HandleBufferFull operation.
For example, the CompressingStream subclass compresses the data, and the
ASCII7Stream converts the data into 7-bit ASCII. Now, to create a FileStream that
compresses its data and converts the compressed binary data to 7-bit ASCII, we
decorate a FileStream with a CompressingStream and an ASCII7Stream:",,,,,,,,
8,1,Use when you want to dynamically add responsibilities to an object by wrapping it in a decorator class.,,,,,,,,
8,1,Dynamically adds responsibilities to an object by wrapping it in an object of a decorator class.,,,,,,,,
8,1,The Decorator pattern dynamically adds responsibilities to an object by wrapping it in an object of a decorator class.,,,,,,,,
8,1,"It provides a flexible alternative to subclassing for extending functionality, allowing for the addition of new behaviors to objects at runtime.",,,,,,,,
8,1,Use when you want to dynamically add additional behaviors or responsibilities to an object without modifying its existing code.,,,,,,,,
8,1,Dynamically adds additional behaviors or responsibilities to an object without modifying its existing code.,,,,,,,,
8,1,Use when you want to add functionality to objects at runtime without changing their structure.,,,,,,,,
9,1,Façade,,,,,,,,
9,1,Structural,,,,,,,,
9,1,Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.,,,,,,,,
9,1,"Structuring a system into subsystems helps reduce complexity. A common design goal is to minimize the communication and dependencies between subsystems. One way to achieve this goal is to introduce a facade object that provides a single, simplified interface to the more general facilities of a subsystem. Consider for example a programming environment that gives applications access
to its compiler subsystem. This subsystem contains classes such as Scanner, Parser,
ProgramNode, BytecodeStream, and ProgramNodeBuilder that implement the compiler.
Some specialized applications might need to access these classes directly. But
most clients of a compiler generally don't care about details like parsing and
code generation; they merely want to compile some code. For them, the powerful
but low-level interfaces in the compiler subsystem only complicate their task.
To provide a higher-level interface that can shield clients from these classes,
the compiler subsystem also includes a Compiler class. This class defines a unified
interface to the compiler's functionality. The Compiler class acts as a facade:
It offers clients a single, simple interface to the compiler subsystem. It glues
together the classes that implement compiler functionality without hiding them
completely. The compiler facade makes life easier for most programmers without
hiding the lower-level functionality from the few that need it. ",,,,,,,,
9,1,"· you want to provide a simple interface to a complex subsystem. Subsystems
often get more complex as they evolve. Most patterns, when applied, result
in more and smaller classes. This makes the subsystem more reusable and
easier to customize, but it also becomes harder to use for clients that
don't need to customize it. A facade can provide a simple default view of
the subsystem that is good enough for most clients. Only clients needing
more customizability will need to look beyond the facade.
· there are many dependencies between clients and the implementation classes
of an abstraction. Introduce a facade to decouple the subsystem from clients
and other subsystems, thereby promoting subsystem independence and
portability.
· you want to layer your subsystems. Use a facade to define an entry point
to each subsystem level. If subsystems are dependent, then you can simplify
the dependencies between them by making them communicate with each other
solely through their facades. ",,,,,,,,
9,1,"· Facade (Compiler) o knows which subsystem classes are responsible for a request. o delegates client requests to appropriate subsystem objects. · subsystem classes (Scanner, Parser, ProgramNode, etc.) o implement subsystem functionality. o handle work assigned by the Facade object. o have no knowledge of the facade; that is, they keep no references to it.",,,,,,,,
9,1,"Clients communicate with the subsystem by sending requests to Facade, which forwards them to the appropriate subsystem object(s). Although the subsystem objects perform the actual work, the facade may have to do work of its own to translate its interface to subsystem interfaces. · Clients that use the facade don't have to access its subsystem objects directly.",,,,,,,,
9,1,"The compiler example in the Sample Code section was inspired by the
ObjectWorks\Smalltalk compiler system.
In the ET++ application framework, an application can have built-in
browsing tools for inspecting its objects at run-time. These browsing tools are
implemented in a separate subsystem that includes a Facade class called
""ProgrammingEnvironment."" This facade defines operations such as InspectObject
and InspectClass for accessing the browsers. An ET++ application can also forgo built-in browsing support. In that case,
ProgrammingEnvironment implements these requests as null operations; that is,
they do nothing. Only the ETProgrammingEnvironment subclass implements these
requests with operations that display the corresponding browsers. The application
has no knowledge of whether a browsing environment is available or not; there's
abstract coupling between the application and the browsing subsystem.
The Choices operating system uses facades to compose many frameworks
into one. The key abstractions in Choices are processes, storage, and address
spaces. For each of these abstractions there is a corresponding subsystem,
implemented as a framework, that supports porting Choices to a variety of different
hardware platforms. Two of these subsystems have a ""representative"" (i.e., facade).
These representatives are FileSystemInterface (storage) and Domain (address
spaces). For example, the virtual memory framework has Domain as its facade. A Domain
represents an address space. It provides a mapping between virtual addresses and
offsets into memory objects, files, or backing store. The main operations on Domain
support adding a memory object at a particular address, removing a memory object,
and handling a page fault.
As the preceding diagram shows, the virtual memory subsystem uses the following
components internally:
· MemoryObject represents a data store.· MemoryObjectCache caches the data of MemoryObjects in physical memory.
MemoryObjectCache is actually a Strategy (349) that localizes the caching
policy.
· AddressTranslation encapsulates the address translation hardware.
The RepairFault operation is called whenever a page fault interrupt occurs. The
Domain finds the memory object at the address causing the fault and delegates
the RepairFault operation to the cache associated with that memory object. Domains
can be customized by changing their components.",,,,,,,,
9,1,"Use when you want to provide a simplified interface to a complex subsystem, making it easier to use for clients.",,,,,,,,
9,1,"The Facade pattern provides a simplified interface to a complex subsystem, acting as a high-level interface that makes the subsystem easier to use.",,,,,,,,
9,1,"It hides the complexities of the subsystem and provides a unified interface for the client to interact with, simplifying the client's interaction with the system.",,,,,,,,
9,1,Use when you have a complex subsystem and want to provide a simplified interface that makes it easier to use for clients.,,,,,,,,
9,1,"Provides a simplified interface to a complex subsystem, making it easier to use for clients.",,,,,,,,
9,1,"Use when you want to simplify the interface of a complex subsystem and provide a high-level interface for clients.
",,,,,,,,
10,1,Flyweight,,,,,,,,
10,1,Structural,,,,,,,,
10,1,Use sharing to support large numbers of fine-grained objects efficiently.,,,,,,,,
10,1,"Some applications could benefit from using objects throughout their design, but a naive implementation would be prohibitively expensive. For example, most document editor implementations have text formatting and editing facilities that are modularized to some extent. Object-oriented document editors typically use objects to represent embedded elements like tables and figures. However, they usually stop short of using an object for each character in the document, even though doing so would promote flexibility at the finest levels in the application. Characters and embedded elements could then be treated uniformly with respect to how they are drawn and formatted. The application could be extended to support new character sets without disturbing other functionality. The application's object structure could mimic the document's physical structure. The following diagram shows how a document editor can use objects to represent characters. The drawback of such a design is its cost. Even moderate-sized documents may require
hundreds of thousands of character objects, which will consume lots of memory
and may incur unacceptable run-time overhead. The Flyweight pattern describes
how to share objects to allow their use at fine granularities without prohibitive
cost. A flyweight is a shared object that can be used in multiple contexts simultaneously.
The flyweight acts as an independent object in each context—it's indistinguishable
from an instance of the object that's not shared. Flyweights cannot make
assumptions about the context in which they operate. The key concept here is the
distinction between intrinsic and extrinsic state. Intrinsic state is stored in
the flyweight; it consists of information that's independent of the flyweight's
context, thereby making it sharable. Extrinsic state depends on and varies with
the flyweight's context and therefore can't be shared. Client objects are
responsible for passing extrinsic state to the flyweight when it needs it.
Flyweights model concepts or entities that are normally too plentiful to represent
with objects. For example, a document editor can create a flyweight for each letter
of the alphabet. Each flyweight stores a character code, but its coordinate
position in the document and its typographic style can be determined from the
text layout algorithms and formatting commands in effect wherever the character
appears. The character code is intrinsic state, while the other information is
extrinsic. Physically, however, there is one shared flyweight object per character, and it
appears in different contexts in the document structure. The class structure for these objects is shown next. Glyph is the abstract class
for graphical objects, some of which may be flyweights. Operations that may depend
on extrinsic state have it passed to them as a parameter. For example, Draw and
Intersects must know which context the glyph is in before they can do their job.A flyweight representing the letter ""a"" only stores the corresponding character
code; it doesn't need to store its location or font. Clients supply the
context-dependent information that the flyweight needs to draw itself. For example,
a Row glyph knows where its children should draw themselves so that they are tiled
horizontally. Thus it can pass each child its location in the draw request.
Because the number of different character objects is far less than the number
of characters in the document, the total number of objects is substantially less
than what a naive implementation would use. A document in which all characters
appear in the same font and color will allocate on the order of 100 character
objects (roughly the size of the ASCII character set) regardless of the document's
length. And since most documents use no more than 10 different font-color
combinations, this number won't grow appreciably in practice. An object
abstraction thus becomes practical for individual characters. ",,,,,,,,
10,1,"The Flyweight pattern's effectiveness depends heavily on how and where it's used. Apply the Flyweight pattern when all of the following are true: · An application uses a large number of objects. · Storage costs are high because of the sheer quantity of objects. · Most object state can be made extrinsic. · Many groups of objects may be replaced by relatively few shared objects once extrinsic state is removed. · The application doesn't depend on object identity. Since flyweight objects may be shared, identity tests will return true for conceptually distinct objects.",,,,,,,,
10,1,"· Flyweight o declares an interface through which flyweights can receive and act on extrinsic state. · ConcreteFlyweight (Character) o implements the Flyweight interface and adds storage for intrinsic state, if any. A ConcreteFlyweight object must be sharable. Any state it stores must be intrinsic; that is, it must be independent of the ConcreteFlyweight object's context. · UnsharedConcreteFlyweight (Row, Column) o not all Flyweight subclasses need to be shared. The Flyweight interface enables sharing; it doesn't enforce it. It's common for UnsharedConcreteFlyweight objects to have ConcreteFlyweight objects as children at some level in the flyweight object structure (as the Row and Column classes have). · FlyweightFactory o creates and manages flyweight objects. o ensures that flyweights are shared properly. When a client requests a flyweight, the FlyweightFactory object supplies an existing instance or creates one, if none exists. · Client o maintains a reference to flyweight(s). o computes or stores the extrinsic state of flyweight(s).",,,,,,,,
10,1,"· State that a flyweight needs to function must be characterized as either intrinsic or extrinsic. Intrinsic state is stored in the ConcreteFlyweight object; extrinsic state is stored or computed by Client objects. Clients
pass this state to the flyweight when they invoke its operations.
· Clients should not instantiate ConcreteFlyweights directly. Clients must
obtain ConcreteFlyweight objects exclusively from the FlyweightFactory
object to ensure they are shared properly.",,,,,,,,
10,1,"The concept of flyweight objects was first described and explored as a design technique in InterViews 3.0. Its developers built a powerful document editor called Doc as a proof of concept. Doc uses glyph objects to represent each character in the document. The editor builds one Glyph instance for each character in a particular style (which defines its graphical attributes); hence a character's intrinsic state consists of the character code and its style information (an index into a style table).4 That means only position is extrinsic, making Doc fast. Documents are represented by a class Document, which also acts as the FlyweightFactory. Measurements on Doc have shown that sharing flyweight characters is quite effective. In a typical case, a document containing 180,000 characters required allocation of only 480 character objects. ET++ uses flyweights to support look-and-feel independence. 5 The look-and-feel standard affects the layout of user interface elements (e.g., scroll bars, buttons, menus—known collectively as ""widgets"") and their decorations (e.g., shadows, beveling). A widget delegates all its layout and drawing behavior to a separate Layout object. Changing the Layout object changes the look and feel, even at run-time. For each widget class there is a corresponding Layout class (e.g., ScrollbarLayout, MenubarLayout, etc.). An obvious problem with this approach is that using separate layout objects doubles the number of user interface objects: For each user interface object there is an additional Layout object. To avoid this overhead, Layout objects are implemented as flyweights. They make good flyweights because they deal mostly with defining behavior, and it's easy to pass them what little extrinsic state they need to lay out or draw an object. The Layout objects are created and managed by Look objects. The Look class is an Abstract Factory (99) that retrieves a specific Layout object with operations like GetButtonLayout, GetMenuBarLayout, and so forth. For each look-and-feel standard there is a corresponding Look subclass (e.g., MotifLook, OpenLook) that supplies the appropriate Layout objects. By the way, Layout objects are essentially strategies (see Strategy (349)). They are an example of a strategy object implemented as a flyweight.",,,,,,,,
10,1,Use when you want to minimize memory usage by sharing common data across multiple objects.,,,,,,,,
10,1,The Flyweight pattern minimizes memory usage by sharing common data across multiple objects.,,,,,,,,
10,1,"It allows for the efficient sharing of objects that have similar or identical states, reducing the memory footprint and improving performance.",,,,,,,,
10,1,Use when you have objects with shared state and want to minimize memory usage by sharing common data across multiple objects.,,,,,,,,
10,1,Minimizes memory usage by sharing common data across multiple objects.,,,,,,,,
10,1,Use when you have objects with shared state and want to minimize memory usage by sharing common data across multiple objects.,,,,,,,,
11,1,Proxy,,,,,,,,
11,1,Structural,,,,,,,,
11,1,Provide a surrogate or placeholder for another object to control access to it.,,,,,,,,
11,1,Surrogate,,,,,,,,
11,1,"One reason for controlling access to an object is to defer the full cost of its creation and initialization until we actually need to use it. Consider a document editor that can embed graphical objects in a document. Some graphical objects, like large raster images, can be expensive to create. But opening a document should be fast, so we should avoid creating all the expensive objects at once when the document is opened. This isn't necessary anyway, because not all of these objects will be visible in the document at the same time. These constraints would suggest creating each expensive object on demand, which in this case occurs when an image becomes visible. But what do we put in the document in place of the image? And how can we hide the fact that the image is created on demand so that we don't complicate the editor's implementation? This optimization shouldn't impact the rendering and formatting code, for example. The solution is to use another object, an image proxy, that acts as a stand-in for the real image. The proxy acts just like the image and takes care of instantiating it when it's required. The image proxy creates the real image only when the document editor asks it to
display itself by invoking its Draw operation. The proxy forwards subsequent
requests directly to the image. It must therefore keep a reference to the image
after creating it. Let's assume that images are stored in separate files. In this case we can use
the file name as the reference to the real object. The proxy also stores its extent,
that is, its width and height. The extent lets the proxy respond to requests for
its size from the formatter without actually instantiating the image.  The document editor accesses embedded images through the interface defined by
the abstract Graphic class. ImageProxy is a class for images that are created
on demand. ImageProxy maintains the file name as a reference to the image on disk.
The file name is passed as an argument to the ImageProxy constructor.
ImageProxy also stores the bounding box of the image and a reference to the real
Image instance. This reference won't be valid until the proxy instantiates the
real image. The Draw operation makes sure the image is instantiated before
forwarding it the request. GetExtent forwards the request to the image only if
it's instantiated; otherwise ImageProxy returns the extent it stores. ",,,,,,,,
11,1,"Proxy is applicable whenever there is a need for a more versatile or sophisticated
reference to an object than a simple pointer. Here are several common situations
in which the Proxy pattern is applicable:
1. A remote proxy provides a local representative for an object in a different
address space. NEXTSTEPuses the class NXProxy for this purpose.
Coplien calls this kind of proxy an ""Ambassador."" 2. A virtual proxy creates expensive objects on demand. The ImageProxy
described in the Motivation is an example of such a proxy.
3. A protection proxy controls access to the original object. Protection
proxies are useful when objects should have different access rights. For
example, KernelProxies in the Choices operating system provide
protected access to operating system objects.
4. A smart reference is a replacement for a bare pointer that performs
additional actions when an object is accessed. Typical uses include
o counting the number of references to the real object so that it can
be freed automatically when there are no more references (also called
smart pointers ).
o loading a persistent object into memory when it's first referenced.
o checking that the real object is locked before it's accessed to ensure
that no other object can change it. ",,,,,,,,
11,1,"· Proxy (ImageProxy)
o maintains a reference that lets the proxy access the real subject.
Proxy may refer to a Subject if the RealSubject and Subject interfaces
are the same.o provides an interface identical to Subject's so that a proxy can
by substituted for the real subject.
o controls access to the real subject and may be responsible for
creating and deleting it.
o other responsibilities depend on the kind of proxy:
§ remote proxies are responsible for encoding a request and
its arguments and for sending the encoded request to the real
subject in a different address space.
§ virtual proxies may cache additional information about the
real subject so that they can postpone accessing it. For
example, the ImageProxy from the Motivation caches the real
image's extent.
§ protection proxies check that the caller has the access
permissions required to perform a request.
· Subject (Graphic)
o defines the common interface for RealSubject and Proxy so that a
Proxy can be used anywhere a RealSubject is expected.
· RealSubject (Image)
o defines the real object that the proxy represents. ",,,,,,,,
11,1,"Proxy forwards requests to RealSubject when appropriate, depending on the kind of proxy.",,,,,,,,
11,1,"The virtual proxy example in the Motivation section is from the ET++ text building block classes. NEXTSTEPuses proxies (instances of class NXProxy) as local representatives for objects that may be distributed. A server creates proxies for remote objects when clients request them. On receiving a message, the proxy encodes it along with its arguments and then forwards the encoded message to the remote subject. Similarly, the subject encodes any return results and sends them back to the NXProxy object. McCullough discusses using proxies in Smalltalk to access remote objects. Pascoe describes how to provide side-effects on method calls and access control with ""Encapsulators.""",,,,,,,,
11,1,Use when you want to provide a surrogate or placeholder for another object to control access to it.,,,,,,,,
11,1,The Proxy pattern provides a surrogate or placeholder for another object to control access to it.,,,,,,,,
11,1,"It allows for the creation of a representative object that can control the access to the original object, providing additional functionality or security checks.",,,,,,,,
11,1,"Use when you want to provide a surrogate or placeholder for another object to control access to it, adding additional functionality or security checks.",,,,,,,,
11,1,Provides a surrogate or placeholder for another object to control access to it.,,,,,,,,
11,1,"Use when you want to control access to an object, add additional functionality, or provide security checks.",,,,,,,,
12,2,Chain of Responsibility,,,,,,,,
12,2,Behavioral,,,,,,,,
12,2,Avoid coupling the sender of a request to its receiver by giving morethan one object a chance to handle the request. Chain the receivingobjects and pass the request along the chain until an objecthandles it.,,,,,,,,
12,2,"Consider a context-sensitive help facility for a graphical userinterface. The
user can obtain help information on any part of theinterface just by clicking
on it. The help that's provided depends onthe part of the interface that's selected
and its context; forexample, a button widget in a dialog box might have different
helpinformation than a similar button in the main window. If no specifichelp
information exists for that part of the interface, thenthe help system should
display a more general help message about theimmediate context—the dialog box
as a whole, for example.
Hence it's natural to organize help information according to itsgenerality—from
the most specific to the most general. Furthermore,it's clear that a help request
is handled by one of several userinterface objects; which one depends on the context
and how specificthe available help is.
The problem here is that the object that ultimately provides thehelp isn't known
explicitly to the object (e.g., the button) that initiates the help request. What
we need is a way to decouple thebutton that initiates the help request from the
objects that mightprovide help information. The Chain of Responsibility pattern
defineshow that happens.
The idea of this pattern is to decouple senders and receivers bygiving multiple
objects a chance to handle a request. The requestgets passed along a chain of
objects until one of them handles it. The first object in the chain receives the request and either handlesit or forwards
it to the next candidate on the chain, which doeslikewise. The object that made
the request has no explicit knowledgeof who will handle it—we say the request
has an implicitreceiver.
Let's assume the user clicks for help on a button widget marked""Print."" The button
is contained in an instance of PrintDialog,which knows the application object
it belongs to (see preceding object diagram).In this case, neither aPrintButton nor aPrintDialog handles therequest; it stops
at anApplication, which can handle it or ignore it.The client that issued the
request has no direct reference to theobject that ultimately fulfills it.
To forward the request along the chain, and to ensure receivers remainimplicit,
each object on the chain shares a common interface forhandling requests and for
accessing its successor on thechain. For example, the help system might define
a HelpHandler classwith a corresponding HandleHelp operation. HelpHandler can
be theparent class for candidate object classes, or it can be defined as amixin
class.The Button, Dialog, and Application classes use HelpHandler operationsto handle
help requests. HelpHandler's HandleHelp operation forwardsthe request to the
successor by default. Subclasses can override thisoperation to provide help under
the right circumstances; otherwisethey can use the default implementation to
forward the request. ",,,,,,,,
12,2,"more than one object may handle a request, and the handler isn't knowna priori. The handler should be ascertained automatically. · you want to issue a request to one of several objects withoutspecifying the receiver explicitly. · the set of objects that can handle a request should be specifieddynamically.",,,,,,,,
12,2,"· Handler (HelpHandler) o defines an interface for handling requests. o (optional) implements the successor link. · ConcreteHandler (PrintButton, PrintDialog) o handles requests it is responsible for. o can access its successor. o if the ConcreteHandler can handle the request, it does so; otherwise it forwards the request to its successor. · Client o initiates the request to a ConcreteHandler object on the chain.",,,,,,,,
12,2,"When a client issues a request, the request propagates along the chainuntil a ConcreteHandler object takes responsibility for handling it.",,,,,,,,
12,2,"Several class libraries use the Chain of Responsibility pattern tohandle user events. They use different names for the Handler class,but the idea is the same: When the user clicks the mouse or presses akey, an event gets generated and passed along the chain.MacApp and ET++ call it ""EventHandler,""Symantec's TCL library calls it ""Bureaucrat,"" andNeXT's AppKituses the name ""Responder."" The Unidraw framework for graphical editors defines Command objectsthat encapsulate requests to Component and ComponentViewobjects. Commands are requests in the sensethat a component or component view may interpret a command to performan operation. This corresponds to the ""requests as objects""approach described in Implementation. Components and component viewsmay be structured hierarchically. A component or a component view mayforward command interpretation to its parent, which may in turnforward it to its parent, and so on, thereby forming a chain ofresponsibility. ET++ uses Chain of Responsibility to handle graphical update. Agraphical object calls the InvalidateRect operation whenever it mustupdate a part of its appearance. A graphical object can't handleInvalidateRect by itself, because it doesn't know enough about itscontext. For example, a graphical object can be enclosed in objectslike Scrollers or Zoomers that transform its coordinate system. Thatmeans the object might be scrolled or zoomed so that it's partiallyout of view. Therefore the default implementation of InvalidateRectforwards the request to the enclosing container object. The lastobject in the forwarding chain is a Window instance. By the timeWindow receives the request, the invalidation rectangle is guaranteedto be transformed properly. The Window handles InvalidateRect bynotifying the window system interface and requesting an update.",,,,,,,,
12,2,"Use when you want to create a chain of objects to handle requests, allowing each object in the chain to decide whether to handle the request or pass it to the next object.",,,,,,,,
12,2,The Chain of Responsibility pattern allows an object to pass a request along a chain of potential handlers until one of them handles the request.,,,,,,,,
12,2,"It decouples the sender of the request from its receivers, giving multiple objects the opportunity to handle the request without explicitly specifying the receiver.",,,,,,,,
12,2,Use when you have a series of objects that can handle a request and you want to pass the request along the chain until one of them handles it. It allows you to decouple the sender of the request from its receiver.,,,,,,,,
12,2,"Creates a chain of objects to handle requests, allowing each object in the chain to decide whether to handle the request or pass it to the next object.",,,,,,,,
12,2,Use when you have multiple objects that can handle a request and want to decouple the sender and receiver of the request.,,,,,,,,
13,2,Command,,,,,,,,
13,2,Behavioral,,,,,,,,
13,2,"Encapsulate a request as an object, thereby letting you parameterizeclients with different requests, queue or log requests, and supportundoable operations.",,,,,,,,
13,2,"Action, Transaction",,,,,,,,
13,2,"Sometimes it's necessary to issue requests to objects without knowinganything about the operation being requested or the receiver of therequest. For example, user interface toolkits include objects likebuttons and menus that carry out a request in response to user input.But the toolkit can't implement the request explicitly in the buttonor menu, because only applications that use the toolkit know whatshould be done on which object. As toolkit designers we have no wayof knowing the receiver of the request or the operations that willcarry it out. The Command pattern lets toolkit objects make requests of unspecifiedapplication objects by turning the request itself into an object. Thisobject can be stored and passed around like other objects. The key tothis pattern is an abstract Command class, which declares an interfacefor executing operations. In the simplest form this interfaceincludes an abstract Execute operation. Concrete Command subclassesspecify a receiver-action pair by storing the receiver as an instancevariable and by implementing Execute to invoke the request. Thereceiver has the knowledge required to carry out the request. Menus can be implemented easily with Command objects. Each choice ina Menu is
an instance of a MenuItem class. An Application class createsthese menus and their
menu items along with the rest of the user interface.The Application class also
keeps track of Document objects that a user hasopened.
The application configures each MenuItem with an instance of aconcrete Command
subclass. When the user selects a MenuItem, theMenuItem calls Execute on its
command, and Execute carries out theoperation. MenuItems don't know which subclass
of Command they use.Command subclasses store the receiver of the request and invoke
one ormore operations on the receiver.
For example, PasteCommand supports pasting text from the clipboardinto a Document.
PasteCommand's receiver is the Document object it issupplied upon instantiation.
The Execute operation invokes Paste onthe receiving Document. OpenCommand's Execute operation is different: it prompts the userfor a document
name, creates a corresponding Document object, adds thedocument to the receiving
application, and opens the document. Sometimes a MenuItem needs to execute a sequence of commands.For example, a
MenuItem for centering a page at normal size could beconstructed from a
CenterDocumentCommand object and aNormalSizeCommand object. Because it's common
to string commandstogether in this way, we can define a MacroCommand class to
allow aMenuItem to execute an open-ended number of commands. MacroCommand isa
concrete Command subclass that simply executes a sequence ofCommands. MacroCommand
has no explicit receiver, because the commandsit sequences define their own
receiver.  In each of these examples, notice how the Command pattern decouplesthe object
that invokes the operation from the one having theknowledge to perform it. This
gives us a lot of flexibility indesigning our user interface. An application can
provide both a menuand a push button interface to a feature just by making the
menu andthe push button share an instance of the same concrete Command subclass.We
can replace commands dynamically, which would be useful forimplementing
context-sensitive menus. We can also support commandscripting by composing
commands into larger ones. All of this ispossible because the object that issues
a request only needs to knowhow to issue it; it doesn't need to know how the request
will be carried out.",,,,,,,,
13,2,"· parameterize objects by an action to perform, as MenuItem objects did above.
You can express such parameterization in a procedural language with a
callback function, that is, a function that's registered somewhere to be
called at a later point. Commands are an object-oriented replacement for
callbacks.· specify, queue, and execute requests at different times. A Command object
can have a lifetime independent of the original request. If the receiver
of a request can be represented in an address space-independent way, then
you can transfer a command object for the request to a different process
and fulfill the request there.
· support undo. The Command's Execute operation can store state for reversing
its effects in the command itself. The Command interface must have an added
Unexecute operation that reverses the effects of a previous call to Execute.
Executed commands are stored in a history list. Unlimited-level undo and
redo is achieved by traversing this list backwards and forwards calling
Unexecute and Execute, respectively.
· support logging changes so that they can be reapplied in case of a system
crash. By augmenting the Command interface with load and store operations,
you can keep a persistent log of changes. Recovering from a crash involves
reloading logged commands from disk and reexecuting them with the Execute
operation.
· structure a system around high-level operations built on primitives
operations. Such a structure is common in information systems that support
transactions. A transaction encapsulates a set of changes to data. The
Command pattern offers a way to model transactions. Commands have a common
interface, letting you invoke all transactions the same way. The pattern
also makes it easy to extend the system with new transactions.",,,,,,,,
13,2,"· Command
o declares an interface for executing an operation.
· ConcreteCommand (PasteCommand, OpenCommand)o defines a binding between a Receiver object and an action.
o implements Execute by invoking the corresponding operation(s) on
Receiver.
· Client (Application)
o creates a ConcreteCommand object and sets its receiver.
· Invoker (MenuItem)
o asks the command to carry out the request.
· Receiver (Document, Application)
o knows how to perform the operations associated with carrying out
a request. Any class may serve as a Receiver.",,,,,,,,
13,2,"· The client creates a ConcreteCommand object and specifies its receiver. · An Invoker object stores the ConcreteCommand object. · The invoker issues a request by calling Execute on the command. Whencommands are undoable, ConcreteCommand stores state for undoing thecommand prior to invoking Execute. · The ConcreteCommand object invokes operations on its receiver to carryout the request.",,,,,,,,
13,2,"Perhaps the first example of the Command pattern appears in a paper byLieberman
. MacApp popularizedthe notion of commands for implementing
undoable operations.ET++, InterViews, andUnidraw also
define classes that follow theCommand pattern. InterViews defines an Action
abstract class thatprovides command functionality. It also defines an
ActionCallbacktemplate, parameterized by action method, that can instantiate
commandsubclasses automatically.
The THINK class library also uses commands to supportundoable actions.
Commands in THINK are called ""Tasks."" Taskobjects are passed along a Chain of
Responsibility (251) for consumption.
Unidraw's command objects are unique in that they can behave likemessages. A
Unidraw command may be sent to another object forinterpretation, and the result
of the interpration varies with thereceiving object. Moreover, the receiver may
delegate theinterpretation to another object, typically the receiver's parent
in alarger structure as in a Chain of Responsibility. The receiver of aUnidraw
command is thus computed rather than stored. Unidraw'sinterpretation mechanism
depends on run-time type information.  Coplien describes how to implement functors, objects thatare functions, in C++
. He achieves a degree oftransparency in their use by overloading the
function call operator(operator()). The Command pattern is different; its focusis
on maintaining a binding between a receiver and a function(i.e., action), not
just maintaining a function. ",,,,,,,,
13,2,"Use when you want to encapsulate a request as an object, allowing you to parameterize clients with different requests, queue or log requests, and support undo operations.",,,,,,,,
13,2,"Encapsulates a request as an object, allowing clients to parameterize clients with different requests, queue or log requests, and support undoable operations.",,,,,,,,
13,2,"The Command pattern encapsulates a request as an object, allowing clients to parameterize clients with different requests, queue or log requests, and support undoable operations.",,,,,,,,
13,2,"It decouples the sender of a request from the object that performs the action, enabling parameterization of clients with different requests and providing flexibility in managing and executing requests.",,,,,,,,
13,2,"Use when you need to encapsulate a request as an object, allowing you to parameterize clients with different requests, queue or log requests, and support undoable operations.",,,,,,,,
13,2,"Encapsulates a request as an object, allowing you to parameterize clients with different requests, queue or log requests, and support undo operations.",,,,,,,,
13,2,"Use when you want to encapsulate a request as an object, allowing you to decouple the sender and receiver of the request.",,,,,,,,
14,2,Interpreter,,,,,,,,
14,2,Behavioral,,,,,,,,
14,2,"Given a language, define a represention for its grammar along with aninterpreter that uses the representation to interpret sentences in thelanguage.",,,,,,,,
14,2,"If a particular kind of problem occurs often enough, then it might beworthwhile
to express instances of the problem as sentences in asimple language. Then you
can build an interpreter that solves theproblem by interpreting these sentences.
For example, searching for strings that match a pattern is a commonproblem. Regular
expressions are a standard language for specifyingpatterns of strings. Rather
than building custom algorithms to matcheach pattern against strings, search
algorithms could interpret aregular expression that specifies a set of strings
to match.
The Interpreter pattern describes how to define a grammar for simplelanguages,
represent sentences in the language, and interpret thesesentences. In this example,
the pattern describes how to define agrammar for regular expressions, represent
a particular regularexpression, and how to interpret that regular expression.
Suppose the following grammar defines the regular expressions:
expression ::= literal | alternation | sequence | repetition |
'(' expression ')'
alternation ::= expression '|' expression
sequence ::= expression '&' expression
repetition ::= expression '*'
literal ::= 'a' | 'b' | 'c' | ... { 'a' | 'b' | 'c' | ... }*
The symbol expression is the start symbol, and literalis a terminal symbol defining
simple words.
The Interpreter pattern uses a class to represent each grammar rule.Symbols on
the right-hand side of the rule are instance variables ofthese classes. The grammar
above is represented by five classes: anabstract class RegularExpression and its
four subclassesLiteralExpression, AlternationExpression, SequenceExpression,
andRepetitionExpression. The last three classes define variables thathold
subexpressions. Every regular expression defined by this grammar is represented by anabstract
syntax tree made up of instances of these classes. Forexample, the abstract syntax
tree represents the regular expression
 raining & (dogs | cats) *
We can create an interpreter for these regular expressions by definingthe Interpret
operation on each subclass of RegularExpression.Interpret takes as an argument the context in which to interpret theexpression. The context contains the input
string and information onhow much of it has been matched so far. Each subclass
ofRegularExpression implements Interpret to match the next part of theinput string
based on the current context. For example,
· LiteralExpression will check if the input matches the literal itdefines,
· AlternationExpression will check if the input matches any of
itsalternatives,
· RepetitionExpression will check if the input has multiple copies
ofexpression it repeats,
and so on.",,,,,,,,
14,2,"Use the Interpreter pattern when there is a language to interpret, andyou can represent statements in the language as abstract syntax trees.The Interpreter pattern works best when · the grammar is simple. For complex grammars, the class hierarchy forthe grammar becomes large and unmanageable. Tools such as parsergenerators are a better alternative in such cases. They can interpretexpressions without building abstract syntax trees, which can savespace and possibly time. · efficiency is not a critical concern. The most efficient interpretersare usually not implemented by interpreting parse trees directlybut by first translating them into another form. For example, regularexpressions are often transformed into state machines. But even then,the translator can be implemented by the Interpreter pattern, sothe pattern is still applicable.",,,,,,,,
14,2,"· AbstractExpression (RegularExpression) o declares an abstract Interpret operation that is common to all nodes in the abstract syntax tree. · TerminalExpression (LiteralExpression) o implements an Interpret operation associated with terminal symbols in the grammar. o an instance is required for every terminal symbol in a sentence. · NonterminalExpression (AlternationExpression,RepetitionExpression, SequenceExpressions) o one such class is required for every rule R ::= R1 R2 ... Rn in the grammar. o maintains instance variables of type AbstractExpression for each of the symbols R1 through Rn. o implements an Interpret operation for nonterminal symbols in the grammar. Interpret typically calls itself recursively on the variables representing R1 through Rn. · Context o contains information that's global to the interpreter. · Client o builds (or is given) an abstract syntax tree representing a particular sentence in the language that the grammar defines. The abstract syntax tree is assembled from instances of the NonterminalExpression and TerminalExpression classes. o invokes the Interpret operation.",,,,,,,,
14,2,· The client builds (or is given) the sentence as an abstract syntaxtree of NonterminalExpression and TerminalExpression instances. Thenthe client initializes the context and invokes the Interpretoperation. · Each NonterminalExpression node defines Interpret in terms ofInterpret on each subexpression. The Interpret operation of eachTerminalExpression defines the base case in the recursion. · The Interpret operations at each node use the context tostore and access the state of the interpreter.,,,,,,,,
14,2,"The Interpreter pattern is widely used in compilers implemented withobject-oriented languages, as the Smalltalk compilers are. SPECTalkuses the pattern to interpret descriptions of input fileformats . The QOCA constraint-solving toolkituses it to evaluate constraints . Considered in its most general form (i.e., an operation distributedover a class hierarchy based on the Composite pattern), nearly everyuse of the Composite pattern will also contain the Interpreterpattern. But the Interpreter pattern should be reserved for thosecases in which you want to think of the class hierarchy as defining alanguage.",,,,,,,,
14,2,Use when you want to define a language and interpret sentences in that language.,,,,,,,,
14,2,"The Interpreter pattern defines a representation for a grammar or language, along with an interpreter that uses the representation to interpret sentences in the language.",,,,,,,,
14,2,It enables the creation of a language or grammar that can be interpreted and executed for specific use cases.,,,,,,,,
14,2,"Use when you need to define a representation for a grammar or language, along with an interpreter that can interpret and execute sentences in that language.",,,,,,,,
14,2,Defines a language and interprets sentences in that language.,,,,,,,,
14,2,Use when you want to define a language and need to interpret and execute sentences in that language.,,,,,,,,
15,2,Iterator,,,,,,,,
15,2,Behavioral,,,,,,,,
15,2,Provide a way to access the elements of an aggregate objectsequentially without exposing its underlying representation.,,,,,,,,
15,2,Cursor,,,,,,,,
15,2,"An aggregate object such as a list should give you a way to access itselements
without exposing its internal structure. Moreover, you mightwant to traverse the
list in different ways, depending on what youwant to accomplish. But you probably
don't want to bloat the Listinterface with operations for different traversals,
even if you couldanticipate the ones you will need. You might also need to have
more thanone traversal pending on the same list.
The Iterator pattern lets you do all this. The key idea in thispattern is to take
the responsibility for access and traversal out ofthe list object and put it into
an iterator object. TheIterator class defines an interface for accessing the list's
elements.An iterator object is responsible for keeping track of the currentelement;
that is, it knows which elements have been traversed already.
For example, a List class would call for a ListIterator with thefollowing
relationship between them: Before you can instantiate ListIterator, you must supply the List totraverse.
Once you have the ListIterator instance, you can access thelist's elements
sequentially. The CurrentItem operation returns thecurrent element in the list,
First initializes the current element tothe first element, Next advances the current element to the nextelement, and IsDone tests whether we've advanced beyond
the lastelement—that is, we're finished with the traversal.
Separating the traversal mechanism from the List object lets us defineiterators
for different traversal policies without enumerating them inthe List interface.
For example, FilteringListIterator might provideaccess only to those elements
that satisfy specific filteringconstraints.
Notice that the iterator and the list are coupled, and the client mustknow that
it is a list that's traversed as opposed to some otheraggregate structure. Hence
the client commits to a particularaggregate structure. It would be better if we
could change the aggregateclass without changing client code. We can do this by
generalizingthe iterator concept to support polymorphic iteration.
As an example, let's assume that we also have a SkipListimplementation of a list.
A skiplist is aprobabilistic data structure with characteristics similar
to balancedtrees. We want to be able to write code that works for both List
andSkipList objects.
We define an AbstractList class that provides a common interfacefor manipulating
lists. Similarly, we need an abstract Iteratorclass that defines a common iteration
interface. Then we can defineconcrete Iterator subclasses for the different list
implementations.As a result, the iteration mechanism becomes independent of
concreteaggregate classes. The remaining problem is how to create the iterator. Since we want towrite code
that's independent of the concrete List subclasses, wecannot simply instantiate
a specific class. Instead, we make the listobjects responsible for creating their corresponding iterator. Thisrequires an operation like CreateIterator through
which clientsrequest an iterator object.
CreateIterator is an example of a factory method (see Factory Method (121)). We
use it here to let a client aska list object for the appropriate iterator. The
Factory Methodapproach give rise to two class hierarchies, one for lists and
anotherfor iterators. The CreateIterator factory method ""connects"" the
twohierarchies. ",,,,,,,,
15,2,"to access an aggregate object's contents without exposing its internalrepresentation. · to support multiple traversals of aggregate objects. · to provide a uniform interface for traversing different aggregatestructures (that is, to support polymorphic iteration).",,,,,,,,
15,2,"· Iterator
o defines an interface for accessing and traversing elements.
· ConcreteIterator
o implements the Iterator interface.o keeps track of the current position in the traversal of the aggregate.
· Aggregate
o defines an interface for creating an Iterator object.
· ConcreteAggregate
o implements the Iterator creation interface to return an instance
of the proper ConcreteIterator.",,,,,,,,
15,2,A ConcreteIterator keeps track of the current object in theaggregate and can compute the succeeding object in thetraversal.,,,,,,,,
15,2,"Iterators are common in object-oriented systems. Most collectionclass libraries offer iterators in one form or another. Here's an example from the Booch components, apopular collection class library. It provides both a fixed size(bounded) and dynamically growing (unbounded) implementation of aqueue. The queue interface is defined by an abstract Queue class. Tosupport polymorphic iteration over the different queueimplementations, the queue iterator is implemented in the terms of theabstract Queue class interface. This variation has the advantage thatyou don't need a factory method to ask the queue implementations fortheir appropriate iterator. However, it requires the interface of theabstract Queue class to be powerful enough to implement the iteratorefficiently. Iterators don't have to be defined as explicitly in Smalltalk. Thestandard collection classes (Bag, Set, Dictionary, OrderedCollection,String, etc.) define an internal iterator method do:, whichtakes a block (i.e., closure) as an argument. Each element in thecollection is bound to the local variable in the block; then the blockis executed. Smalltalk also includes a set of Stream classes thatsupport an iterator-like interface. ReadStream is essentially anIterator, and it can act as an external iterator for all thesequential collections. There are no standard external iterators fornonsequential collections such as Set and Dictionary. Polymorphic iterators and the cleanup Proxy described earlier areprovided by the ET++ container classes. The Unidrawgraphical editing framework classes use cursor-basediterators. ObjectWindows 2.0 provides a class hierarchy ofiterators for containers. You can iterate over different containertypes in the same way. The ObjectWindow iteration syntax relies onoverloading the postincrement operator ++ to advance theiteration.",,,,,,,,
15,2,Use when you want to provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.,,,,,,,,
15,2,The Iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.,,,,,,,,
15,2,"It decouples the algorithm for accessing elements from the aggregate object, allowing multiple traversal algorithms to operate on the same collection without modifying its structure.",,,,,,,,
15,2,Use when you need to provide a way to sequentially access elements of a collection without exposing its underlying representation. It allows you to traverse the collection without modifying its structure.,,,,,,,,
15,2,Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.,,,,,,,,
15,2,Use when you want to traverse the elements of a collection without exposing the underlying structure of the collection.,,,,,,,,
16,2,Mediator,,,,,,,,
16,2,Behavioral,,,,,,,,
16,2,"Define an object that encapsulates how a set of objects interact.Mediator promotes loose coupling by keeping objects from referring toeach other explicitly, and it lets you vary their interactionindependently.",,,,,,,,
16,2,"Object-oriented design encourages the distribution of behavioramong objects. Such
distribution can result in an object structurewith many connections between
objects; in the worst case, every objectends up knowing about every other.
Though partitioning a system into many objects generally enhancesreusability,
proliferating interconnections tend to reduce it again.Lots of interconnections
make it less likely that an object can workwithout the support of others—the system
acts as though it weremonolithic. Moreover, it can be difficult to change the
system'sbehavior in any significant way, since behavior is distributed amongmany
objects. As a result, you may be forced to define many subclassesto customize
the system's behavior.
As an example, consider the implementation of dialog boxes in agraphical user
interface. A dialog box uses a window to present acollection of widgets such as
buttons, menus, and entry fields, asshown here: Often there are dependencies between the widgets in the dialog. Forexample, a
button gets disabled when a certain entry field is empty.Selecting an entry in
a list of choices called a list boxmight change the contents of an entry field.
Conversely, typing textinto the entry field might automatically select one or
morecorresponding entries in the list box. Once text appears in the entryfield,
other buttons may become enabled that let the user do somethingwith the text,
such as changing or deleting the thing to which it refers.
Different dialog boxes will have different dependencies betweenwidgets. So even
though dialogs display the same kinds of widgets,they can't simply reuse stock
widget classes; they have to becustomized to reflect dialog-specific dependencies.
Customizing themindividually by subclassing will be tedious, since many classes
areinvolved.
You can avoid these problems by encapsulating collective behavior in aseparate
mediator object. A mediator is responsible forcontrolling and coordinating the
interactions of a group of objects.The mediator serves as an intermediary that
keeps objects in the groupfrom referring to each other explicitly. The objects
only know themediator, thereby reducing the number of interconnections.
For example, FontDialogDirector can be the mediatorbetween the widgets in a dialog
box. A FontDialogDirector object knowsthe widgets in a dialog and coordinates
their interaction. It acts asa hub of communication for widgets: The following interaction diagram illustrates how the objects cooperate tohandle
a change in a list box's selection: Here's the succession of events by which a list box's selection passesto an entry
field:
1. The list box tells its director that it's changed.
2. The director gets the selection from the list box.
3. The director passes the selection to the entry field.
4. Now that the entry field contains some text, the directorenables button(s)
for initiating an action (e.g., ""demibold,"" ""oblique""). Note how the director mediates between the list box and the entry field.Widgets
communicate with each other only indirectly, through thedirector. They don't have
to know about each other; all they know is thedirector. Furthermore, because the
behavior is localized in one class,it can be changed or replaced by extending
or replacing that class.
Here's how the FontDialogDirector abstraction can be integrated into aclass
library: DialogDirector is an abstract class that defines the overall behavior ofa dialog.
Clients call the ShowDialog operation to display the dialog onthe screen.
CreateWidgets is an abstract operation for creating thewidgets of a dialog.
WidgetChanged is another abstract operation;widgets call it to inform their
director that they have changed.DialogDirector subclasses override CreateWidgets
to create the properwidgets, and they override WidgetChanged to handle the changes.",,,,,,,,
16,2,· a set of objects communicate in well-defined but complex ways. Theresulting interdependencies are unstructured and difficult tounderstand. · reusing an object is difficult because it refers to and communicateswith many other objects. · a behavior that's distributed between several classes should becustomizable without a lot of subclassing.,,,,,,,,
16,2,"· Mediator (DialogDirector) o defines an interface for communicating with Colleague objects. · ConcreteMediator (FontDialogDirector) o implements cooperative behavior by coordinating Colleague objects. o knows and maintains its colleagues. · Colleague classes (ListBox, EntryField) o each Colleague class knows its Mediator object. o each colleague communicates with its mediator whenever it would have otherwise communicated with another colleague.",,,,,,,,
16,2,Colleagues send and receive requests from a Mediator object. Themediator implements the cooperative behavior by routing requestsbetween the appropriate colleague(s).,,,,,,,,
16,2,"Both ET++ and the THINK C class library usedirector-like objects
in dialogs as mediators between widgets.
The application architecture of Smalltalk/V for Windows is based on amediator
structure. In that environment, anapplication consists of a Window
containing a set of panes. Thelibrary contains several predefined Pane objects;
examples includeTextPane, ListBox, Button, and so on.These panes can be used
without subclassing. An application developeronly subclasses from ViewManager,
a class that's responsible for doinginter-pane coordination. ViewManager is the
Mediator, and each paneonly knows its view manager, which is considered the ""owner""
of thepane. Panes don't refer to each other directly.
The following object diagram shows a snapshot of an application atrun-time:Smalltalk/V uses an event mechanism for Pane-ViewManagercommunication. A pane
generates an event when it wants to getinformation from the mediator or when it
wants to inform the mediatorthat something significant happened. An event defines
a symbol (e.g.,#select) that identifies the event. To handle the event, theview
manager registers a method selector with the pane. This selectoris the event's
handler; it will be invoked whenever the event occurs.
The following code excerpt shows how a ListPane object gets created insidea
ViewManager subclass and how ViewManager registers an event handlerfor the #select
event: Another application of the Mediator pattern is in coordinating complexupdates.
An example is the ChangeManager class mentioned in Observer (326). ChangeManager
mediates betweensubjects and observers to avoid redundant updates. When an
objectchanges, it notifies the ChangeManager, which in turn coordinates theupdate
by notifying the object's dependents.
A similar application appears in the Unidraw drawingframework and uses
a class called CSolver toenforce connectivity constraints between ""connectors.""
Objects ingraphical editors can appear to stick to one another in differentways.
Connectors are useful in applications that maintainconnectivity automatically,
like diagram editors and circuit designsystems. CSolver is a mediator between
connectors. It solves theconnectivity constraints and updates the connectors'
positions toreflect them. ",,,,,,,,
16,2,"Use when you want to define an object that encapsulates how a group of objects interact, promoting loose coupling and reducing direct dependencies between objects.",,,,,,,,
16,2,"Defines an object that encapsulates how a group of objects interact, promoting loose coupling and reducing direct dependencies between objects.",,,,,,,,
16,2,Use when you have a complex interaction between a group of objects and want to centralize the communication and reduce dependencies.,,,,,,,,
17,2,Memento,,,,,,,,
17,2,Behavioral,,,,,,,,
17,2,"Without violating encapsulation, capture and externalize an object'sinternal state so that the object can be restored to this state later.",,,,,,,,
17,2,Token,,,,,,,,
17,2,"Sometimes it's necessary to record the internal state of an object.This is required
when implementing checkpoints and undo mechanismsthat let users back out of
tentative operations or recover fromerrors. You must save state information
somewhere so that you canrestore objects to their previous states. But objects
normallyencapsulate some or all of their state, making it inaccessible toother
objects and impossible to save externally. Exposing this statewould violate
encapsulation, which can compromise the application'sreliability and
extensibility.
Consider for example a graphical editor that supports connectivitybetween objects.
A user can connect two rectangles with a line, andthe rectangles stay connected
when the user moves either of them. Theeditor ensures that the line stretches
to maintain the connection. A well-known way to maintain connectivity relationships betweenobjects is with
a constraint-solving system. We can encapsulate thisfunctionality in a
ConstraintSolver object.ConstraintSolver records connections as they are made
and generatesmathematical equations that describe them. It solves these
equationswhenever the user makes a connection or otherwise modifies thediagram.
ConstraintSolver uses the results of its calculations torearrange the graphics
so that they maintain the proper connections. Supporting undo in this application isn't as easy as it may seem. Anobvious way
to undo a move operation is to store the original distancemoved and move the object
back an equivalent distance. However, thisdoes not guarantee all objects will
appear where they did before.Suppose there is some slack in the connection. In
that case, simplymoving the rectangle back to its original location won't
necessarilyachieve the desired effect. In general, the ConstraintSolver's public interface might beinsufficient to allow
precise reversal of its effects on otherobjects. The undo mechanism must work
more closely withConstraintSolver to reestablish previous state, but we should
alsoavoid exposing the ConstraintSolver's internals to the undo mechanism.
We can solve this problem with the Memento pattern. A memento is an object that
stores a snapshot of theinternal state of another object — the memento's originator.
The undo mechanism will request a mementofrom the originator when it needs to
checkpoint the originator'sstate. The originator initializes the memento with
information thatcharacterizes its current state. Only the originator can store
andretrieve information from the memento—the memento is ""opaque"" toother objects.
In the graphical editor example just discussed, the ConstraintSolver can actas
an originator. The following sequence of events characterizes theundo process:
1. The editor requests a memento from the ConstraintSolver as aside-effect
of the move operation.
2. The ConstraintSolver creates and returns a memento, an instance of aclass
SolverState in this case. A SolverState memento contains datastructures
that describe the current state of the ConstraintSolver'sinternal
equations and variables.
3. Later when the user undoes the move operation, the editor gives
theSolverState back to the ConstraintSolver.
4. Based on the information in the SolverState, the ConstraintSolverchanges
its internal structures to return its equations and variablesto their exact
previous state.
This arrangement lets the ConstraintSolver entrust other objects withthe
information it needs to revert to a previous state withoutexposing its internal
structure and representations. ",,,,,,,,
17,2,"· a snapshot of (some portion of) an object's state must be saved sothat it can be restored to that state later, and · a direct interface to obtaining the state would exposeimplementation details and break the object's encapsulation.",,,,,,,,
17,2,"· Memento (SolverState) o stores internal state of the Originator object. The memento may store as much or as little of the originator's internal state as necessary at its originator's discretion. o protects against access by objects other than the originator. Mementos have effectively two interfaces. Caretaker sees a narrow interface to the Memento—it can only pass the memento to other objects. Originator, in contrast, sees a wide interface, one that lets it access all the data necessary to restore itself to its previous state. Ideally, only the originator that produced the memento would be permitted to access the memento's internal state. · Originator (ConstraintSolver) o creates a memento containing a snapshot of its current internal state. o uses the memento to restore its internal state. · Caretaker (undo mechanism) o is responsible for the memento's safekeeping. o never operates on or examines the contents of a memento.",,,,,,,,
17,2,"A caretaker requests a memento from an originator, holds it for atime, and passes it back to the originator, as the followinginteraction diagram illustrates: Sometimes the caretaker won't pass the memento back to the
originator,because the originator might never need to revert to an earlier
state.
· Mementos are passive. Only the originator that created a memento willassign
or retrieve its state.",,,,,,,,
17,2,"The preceding sample code is based on Unidraw's support for connectivitythrough
its CSolver class.
Collections in Dylan provide an iteration interface thatreflects the
Memento pattern. Dylan's collections have the notion of a""state"" object, which
is a memento that represents the state of theiteration. Each collection can
represent the current state of theiteration in any way it chooses; the
representation is completelyhidden from clients. The Dylan iteration approach
might be translatedto C++ as follows: CreateInitialState returns an initializedIterationState object for the collection.
Next advancesthe state object to the next position in the iteration; it
effectivelyincrements the iteration index. IsDone returnstrue if Next has advanced
beyond the last elementin the collection. CurrentItem dereferences the stateobject
and returns the element in the collection to which it refers.Copy returns a copy
of the given state object. This isuseful for marking a point in an iteration. The memento-based iteration interface has two interesting benefits:
1. More than one state can work on the same collection. (The sameis true of
the Iterator (289) pattern.)
2. It doesn't require breaking a collection's encapsulationto support
iteration. The memento is only interpreted by thecollection itself; no one
else has access to it. Other approaches toiteration require breaking
encapsulation by making iterator classesfriends of their collection
classes (see Iterator (289)). The situation is reversed in thememento-based
implementation: Collection is a friend of theIteratorState.
The QOCA constraint-solving toolkit stores incremental information inmementos
. Clients can obtain a memento that characterizesthe current solution
to a system of constraints. The memento containsonly those constraint variables
that have changed since the lastsolution. Usually only a small subset of the
solver's variableschanges for each new solution. This subset is enough to return
thesolver to the preceding solution; reverting to earlier solutionsrequires
restoring mementos from the intervening solutions. Hence youcan't set mementos
in any order; QOCA relies on a history mechanism torevert to earlier solutions. ",,,,,,,,
17,2,"Use when you want to capture and restore an object's internal state without violating encapsulation, providing undo and redo functionality.",,,,,,,,
17,2,"Captures and restores an object's internal state without violating encapsulation, providing undo and redo functionality.",,,,,,,,
17,2,"Use when you want to save and restore the state of an object, or provide undo and redo operations.",,,,,,,,
18,2,Observer,,,,,,,,
18,2,Behavioral,,,,,,,,
18,2,"Define a one-to-many dependency between objects so that when oneobject changes state, all its dependents are notified and updatedautomatically.",,,,,,,,
18,2,"Dependents, Publish-Subscribe",,,,,,,,
18,2,"A common side-effect of partitioning a system into a collection ofcooperating
classes is the need to maintain consistency betweenrelated objects. You don't
want to achieve consistency by making theclasses tightly coupled, because that
reduces their reusability.
For example, many graphical user interface toolkits separate thepresentational
aspects of the user interface from the underlyingapplication data.Classes defining application data and presentations can be
reusedindependently. They can work together, too. Both a spreadsheet objectand
bar chart object can depict information in the same application dataobject using
different presentations. The spreadsheet and the bar chartdon't know about each
other, thereby letting you reuse only the one youneed. But they behave as though
they do. When the user changes theinformation in the spreadsheet, the bar chart
reflects the changesimmediately, and vice versa. This behavior implies that the spreadsheet and bar chart are dependenton the data
object and therefore should be notified of any change inits state. And there's
no reason to limit the number of dependentobjects to two; there may be any number
of different user interfacesto the same data.
The Observer pattern describes how to establish these relationships.The key
objects in this pattern are subject andobserver. A subject may have any number
of dependentobservers. All observers are notified whenever the subject undergoesa
change in state. In response, each observer will query the subjectto synchronize
its state with the subject's state.
This kind of interaction is also known aspublish-subscribe. The subject is the
publisher ofnotifications. It sends out these notifications without having to
knowwho its observers are. Any number of observers can subscribe toreceive
notifications. ",,,,,,,,
18,2,"· When an abstraction has two aspects, one dependent on the other.Encapsulating these aspects in separate objects lets you vary andreuse them independently. · When a change to one object requires changing others, and youdon't know how many objects need to be changed. · When an object should be able to notify other objects without makingassumptions about who these objects are. In other words, you don'twant these objects tightly coupled.",,,,,,,,
18,2,· Subject o knows its observers. Any number of Observer objects may observe a subject. o provides an interface for attaching and detaching Observer objects. · Observer o defines an updating interface for objects that should be notified of changes in a subject. · ConcreteSubject o stores state of interest to ConcreteObserver objects. o sends a notification to its observers when its state changes. · ConcreteObserver o maintains a reference to a ConcreteSubject object. o stores state that should stay consistent with the subject's. o implements the Observer updating interface to keep its state consistent with the subject's.,,,,,,,,
18,2,"· ConcreteSubject notifies its observers whenever a changeoccurs that could make its observers' state inconsistent with its own. · After being informed of a change in the concrete subject, aConcreteObserver object may query the subject for information.ConcreteObserver uses this information to reconcile its state with thatof the subject.Note how the Observer object that initiates the change requestpostpones
its update until it gets a notification from the subject.Notify is not always
called by the subject. It can be called by anobserver or by another kind
of object entirely. The Implementationsection discusses some common
variations. ",,,,,,,,
18,2,"The first and perhaps best-known example of the Observer pattern appearsin Smalltalk Model/View/Controller (MVC), the user interface framework in the Smalltalkenvironment. MVC's Model class plays the role ofSubject, while View is the base class for observers. Smalltalk,ET++, and the THINK class library provide ageneral dependency mechanism by putting Subject and Observer interfacesin the parent class for all other classes in the system. Other user interface toolkits that employ this pattern areInterViews, the AndrewToolkit, and Unidraw. InterViewsdefines Observer and Observable (for subjects) classes explicitly.Andrew calls them ""view"" and ""data object,"" respectively. Unidrawsplits graphical editor objects into View (for observers) and Subjectparts.",,,,,,,,
18,2,"Use when you want to establish a one-to-many dependency between objects, so that when one object changes its state, all its dependents are notified and updated automatically.",,,,,,,,
18,2,"Defines a one-to-many dependency between objects, so that when one object changes state, all its dependents are notified and updated automatically.",,,,,,,,
18,2,"The Observer pattern establishes a one-to-many dependency between objects, so that when one object (called the subject) changes its state, all its dependents (called observers) are notified and updated automatically",,,,,,,,
18,2,"This pattern allows loose coupling between the subject and observers, enabling easy addition and removal of observers without affecting the subject.",,,,,,,,
18,2,"Use when you need to implement a one-to-many dependency between objects, where changes in one object should automatically notify and update other dependent objects.",,,,,,,,
18,2,"Establishes a one-to-many dependency between objects, so that when one object changes its state, all its dependents are notified and updated automatically.",,,,,,,,
18,2,"Use when you want to establish a loosely coupled relationship between objects, where changes in one object trigger updates in other dependent objects.",,,,,,,,
19,2,State,,,,,,,,
19,2,Behavioral,,,,,,,,
19,2,Allow an object to alter its behavior when its internal state changes.The object will appear to change its class.,,,,,,,,
19,2,Objects for States,,,,,,,,
19,2,"Consider a class TCPConnection that represents a network connection.A
TCPConnection object can be in one of several different states:Established,
Listening, Closed. When a TCPConnection object receivesrequests from other objects,
it responds differently depending on itscurrent state. For example, the effect
of an Open request depends onwhether the connection is in its Closed state or
its Establishedstate. The State pattern describes how TCPConnection can
exhibitdifferent behavior in each state.
The key idea in this pattern is to introduce an abstract class calledTCPState
to represent the states of the network connection. TheTCPState class declares
an interface common to all classes thatrepresent different operational states.
Subclasses of TCPStateimplement state-specific behavior. For example, the
classesTCPEstablished and TCPClosed implement behavior particular to
theEstablished and Closed states of TCPConnection. The class TCPConnection maintains a state object (an instance of asubclass of
TCPState) that represents the current state of the TCPconnection. The class
TCPConnection delegates all state-specificrequests to this state object.
TCPConnection uses its TCPStatesubclass instance to perform operations particular
to the state of theconnection.
Whenever the connection changes state, the TCPConnection objectchanges the state
object it uses. When the connection goes fromestablished to closed, for example,
TCPConnection will replace itsTCPEstablished instance with a TCPClosed instance. ",,,,,,,,
19,2,"· An object's behavior depends on its state, and it must change itsbehavior at run-time depending on that state. · Operations have large, multipart conditional statements that depend onthe object's state. This state is usually represented by one or moreenumerated constants. Often, several operations will contain thissame conditional structure. The State pattern puts each branch of theconditional in a separate class. This lets you treat the object'sstate as an object in its own right that can vary independently fromother objects.",,,,,,,,
19,2,"· Context (TCPConnection)
o defines the interface of interest to clients.
o maintains an instance of a ConcreteState subclass that defines
thecurrent state.· State (TCPState)
o defines an interface for encapsulating the behavior associated with
aparticular state of the Context.
· ConcreteState subclasses (TCPEstablished, TCPListen, TCPClosed)
o each subclass implements a behavior associated with a state ofthe
Context. ",,,,,,,,
19,2,"· Context delegates state-specific requests to the current ConcreteStateobject. · A context may pass itself as an argument to the State objecthandling the request. This lets the State object accessthe context if necessary. · Context is the primary interface for clients. Clients can configure acontext with State objects. Once a context is configured, its clients don't have to deal with the State objects directly. · Either Context or the ConcreteState subclasses can decide which statesucceeds another and under what circumstances.",,,,,,,,
19,2,"Johnson and Zweig characterize theState pattern and its application to
TCP connection protocols.
Most popular interactive drawing programs provide ""tools"" forperforming
operations by direct manipulation. For example, aline-drawing tool lets a user
click and drag to create a new line. Aselection tool lets the user select shapes.
There's usually a paletteof such tools to choose from. The user thinks of this
activity aspicking up a tool and wielding it, but in reality the editor'sbehavior
changes with the current tool: When a drawing tool is activewe create shapes;when the selection tool is active we select shapes;and so forth. We can use the
State pattern to change the editor'sbehavior depending on the current tool.
We can define an abstract Tool class from which to define subclassesthat implement
tool-specific behavior. The drawing editor maintains acurrent Tool object and
delegates requests to it. It replaces thisobject when the user chooses a new tool,
causing the behavior of thedrawing editor to change accordingly.
This technique is used in both the HotDraw and Unidraw drawing
editor frameworks. It allows clients to define new kinds of tools easily. In HotDraw,
the DrawingController class forwards the requests to the current Tool object.
In Unidraw, the corresponding classes are Viewer and Tool. The following class
diagram sketches the Tool and DrawingController interfaces: Coplien's Envelope-Letter idiom is related toState. Envelope-Letter is
a technique for changing an object's class atrun-time. The State pattern is more
specific, focusing on how to dealwith an object whose behavior depends on its
state. ",,,,,,,,
19,2,"Use when you want to allow an object to alter its behavior when its internal state changes, encapsulating the state-specific logic into separate classes.",,,,,,,,
19,2,"Allows an object to alter its behavior when its internal state changes, encapsulating the state-specific logic into separate classes.",,,,,,,,
19,2,Use when you have an object with multiple states and want to encapsulate the behavior associated with each state into separate classes.,,,,,,,,
20,2,Strategy,,,,,,,,
20,2,Behavioral,,,,,,,,
20,2,"Define a family of algorithms, encapsulate each one, and make theminterchangeable. Strategy lets the algorithm vary independently fromclients that use it.",,,,,,,,
20,2,Policy,,,,,,,,
20,2,"Many algorithms exist for breaking a stream of text into lines.Hard-wiring all
such algorithms into the classes that require themisn't desirable for several
reasons:
· Clients that need linebreaking get more complex if they includethe
linebreaking code. That makes clients bigger and harder tomaintain,
especially if they support multiple linebreaking algorithms.
· Different algorithms will be appropriate at different times. We don'twant
to support multiple linebreaking algorithms if we don't use themall.
· It's difficult to add new algorithms and vary existing ones whenlinebreaking
is an integral part of a client.
We can avoid these problems by defining classes that encapsulatedifferent
linebreaking algorithms. An algorithm that's encapsulated inthis way is called
a strategy. Suppose a Composition class is responsible for maintaining andupdating the
linebreaks of text displayed in a text viewer.Linebreaking strategies aren'timplemented by the class Composition.Instead, they are implemented separately
by subclasses of the abstractCompositor class. Compositor subclasses implement
different strategies:
· SimpleCompositorimplements a simple strategy that determines linebreaks
one at atime.
· TeXCompositorimplements the TeX algorithm for finding linebreaks. This
strategytries to optimize linebreaks globally, that is, one paragraph at
atime.
· ArrayCompositorimplements a strategy that selects breaks so that each row
has a fixednumber of items. It's useful for breaking a collection of icons
intorows, for example.
A Composition maintains a reference to a Compositor object. Whenever aComposition
reformats its text, it forwards this responsibility to itsCompositor object. The
client of Composition specifies whichCompositor should be used by installing the
Compositor it desires intothe Composition. ",,,,,,,,
20,2,"· many related classes differ only in their behavior. Strategiesprovide a way to configure a class with one of many behaviors. · you need different variants of an algorithm. For example, you might definealgorithms reflecting different space/time trade-offs.Strategies can be used when these variants are implemented as a classhierarchy of algorithms. · an algorithm uses data that clients shouldn't know about. Use theStrategy pattern to avoid exposing complex, algorithm-specific datastructures. · a class defines many behaviors, and these appear as multipleconditional statements in its operations. Instead of manyconditionals, move related conditional branches into their ownStrategy class.",,,,,,,,
20,2,"· Strategy (Compositor) o declares an interface common to all supported algorithms. Context uses this interface to call the algorithm defined by a ConcreteStrategy. · ConcreteStrategy (SimpleCompositor, TeXCompositor,ArrayCompositor) o implements the algorithm using the Strategy interface. · Context (Composition) o is configured with a ConcreteStrategy object. o maintains a reference to a Strategy object. o may define an interface that lets Strategy access its data.",,,,,,,,
20,2,"· Strategy and Context interact to implement the chosen algorithm. Acontext may pass all data required by the algorithm to the strategywhen the algorithm is called. Alternatively, the context can passitself as an argument to Strategy operations. That lets the strategycall back on the context as required. · A context forwards requests from its clients to its strategy. Clientsusually create and pass a ConcreteStrategy object to the context;thereafter, clients interact with the context exclusively. There isoften a family of ConcreteStrategy classes for a client to choosefrom.",,,,,,,,
20,2,"Use when you want to define a family of algorithms, encapsulate each one, and make them interchangeable at runtime.",,,,,,,,
20,2,"Defines a family of interchangeable algorithms, encapsulating each one and making them interchangeable within the context.",,,,,,,,
20,2,"The Strategy pattern defines a family of interchangeable algorithms, encapsulating each algorithm and making them interchangeable within the context.",,,,,,,,
20,2,"It allows the algorithm to vary independently from the clients that use it, promoting flexibility and enabling dynamic selection of algorithms at runtime.",,,,,,,,
20,2,Use when you have a family of algorithms and want to make them interchangeable within a context. It allows you to select and use different algorithms dynamically at runtime.,,,,,,,,
20,2,"Defines a family of algorithms, encapsulates each one, and makes them interchangeable at runtime.",,,,,,,,
20,2,Use when you have multiple algorithms that can be used interchangeably and want to decouple the algorithm implementation from the client code.,,,,,,,,
21,2,Template Method,,,,,,,,
21,2,Behavioral,,,,,,,,
21,2,"Define the skeleton of an algorithm in an operation, deferring somesteps to subclasses. Template Method lets subclasses redefinecertain steps of an algorithm without changing the algorithm'sstructure.",,,,,,,,
21,2,"Consider an application framework that provides Application andDocument classes. 
The Application class is responsible for openingexisting documents stored in an 
external format, such as a file. ADocument object represents the information in 
a document once it'sread from the file. 
Applications built with the framework can subclass Application andDocument to 
suit specific needs. For example, a drawing applicationdefines DrawApplication 
and DrawDocument subclasses; a spreadsheetapplication defines 
SpreadsheetApplication and SpreadsheetDocumentsubclasses. OpenDocument defines each step for opening a document. It checks ifthe document 
can be opened, creates the application-specific Documentobject, adds it to its 
set of documents, and reads the Document from afile. 
We call OpenDocument a template method. A template methoddefines an algorithm 
in terms of abstract operations that subclassesoverride to provide concrete 
behavior. Application subclasses definethe steps of the algorithm that check if 
the document can be opened(CanOpenDocument) and that create the Document 
(DoCreateDocument).Document classes define the step that reads the document 
(DoRead).The template method also defines an operation that lets 
Applicationsubclasses know when the document is about to be 
opened(AboutToOpenDocument), in case they care. 
By defining some of the steps of an algorithm using abstractoperations, the 
template method fixes their ordering, but it letsApplication and Document 
subclasses vary those steps to suit theirneeds. ",,,,,,,,
21,2,"· to implement the invariant parts of an algorithm once and leave it upto 
subclasses to implement the behavior that can vary. 
· when common behavior among subclasses should be factored and localizedin 
a common class to avoid code duplication. This is a good example 
of""refactoring to generalize"" as described by Opdyke andJohnson. 
You first identify thedifferences in the existing code and then separate 
the differencesinto new operations. Finally, you replace the differing code 
with atemplate method that calls one of these new operations. 
· to control subclasses extensions. You can define a template methodthat calls 
""hook"" operations (see Consequences) at specific points,thereby permitting 
extensions only at those points. ",,,,,,,,
21,2,"· AbstractClass (Application) 
o defines abstract primitive operations that concretesubclasses 
define to implement steps of an algorithm. 
o implements a template method defining the skeleton of an 
algorithm.The template method calls primitive operations as well 
as operationsdefined in AbstractClass or those of other objects. 
· ConcreteClass (MyApplication) 
o implements the primitive operations to carry out 
subclass-specificsteps of the algorithm. ",,,,,,,,
21,2,ConcreteClass relies on AbstractClass to implement the invariant steps of the algorithm.,,,,,,,,
21,2,Template methods are so fundamental that they can be found in almostevery abstract class. Wirfs-Brock et al.  provide a good overview anddiscussion of template methods.,,,,,,,,
21,2,"Use when you want to define the skeleton of an algorithm in a base class, allowing subclasses to provide specific implementations of certain steps.",,,,,,,,
21,2,"The Template Method pattern defines the skeleton of an algorithm in a base class, allowing subclasses to redefine certain steps of the algorithm without changing its structure.",,,,,,,,
21,2,"It promotes code reuse and provides a way to define a common structure for a group of related algorithms while allowing variations in specific steps.
",,,,,,,,
21,2,Use when you want to define a common skeleton for a group of related algorithms while allowing variations in specific steps. It enables code reuse and provides a way to define a common structure.,,,,,,,,
21,2,"Defines the skeleton of an algorithm in a base class, allowing subclasses to provide specific implementations of certain steps.",,,,,,,,
21,2,"Use when you have an algorithm with a fixed structure but varying implementation details, and want to provide a template for the algorithm in a base class.",,,,,,,,
22,2,Visitor,,,,,,,,
22,2,Behavioral,,,,,,,,
22,2,Represent an operation to be performed on the elements of an objectstructure. Visitor lets you define a new operation without changing theclasses of the elements on which it operates.,,,,,,,,
22,2,"Consider a compiler that represents programs as abstract syntax trees.It will 
need to perform operations on abstract syntax trees for ""staticsemantic"" analyses 
like checking that all variables are defined. Itwill also need to generate code. 
So it might define operations fortype-checking, code optimization, flow analysis, 
checking for variablesbeing assigned values before they're used, and so on. 
Moreover, we coulduse the abstract syntax trees for pretty-printing, 
programrestructuring, code instrumentation, and computing various metrics of 
aprogram. 
Most of these operations will need to treat nodes that representassignment 
statements differently from nodes that represent variables orarithmetic 
expressions. Hence there will be one class for assignmentstatements, another for 
variable accesses, another for arithmeticexpressions, and so on. The set of node 
classes depends on the languagebeing compiled, of course, but it doesn't change 
much for a givenlanguage.  We can have both by packaging related operations from each class in aseparate 
object, called a visitor, and passing it toelements of the abstract syntax tree 
as it's traversed. When an element""accepts"" the visitor, it sends a request to 
the visitor that encodesthe element's class. It also includes the element as an 
argument. Thevisitor will then execute the operation for that element—theoperation 
that used to be in the class of the element. 
For example, a compiler that didn't use visitors might type-check aprocedure by 
calling the TypeCheck operation on its abstract syntaxtree. Each of the nodes 
would implement TypeCheck by calling TypeCheckon its components (see the preceding 
class diagram). If the compilertype-checked a procedure using visitors, then it 
would create aTypeCheckingVisitor object and call the Accept operation on 
theabstract syntax tree with that object as an argument. Each of thenodes would 
implement Accept by calling back on the visitor: anassignment node calls 
VisitAssignment operation on the visitor, whilea variable reference calls 
VisitVariableReference. What used to be theTypeCheck operation in class 
AssignmentNode is now the VisitAssignmentoperation on TypeCheckingVisitor. 
To make visitors work for more than just type-checking, we need anabstract parent 
class NodeVisitor for all visitors of an abstract syntaxtree. NodeVisitor must 
declare an operation for each node class. Anapplication that needs to compute 
program metrics will define newsubclasses of NodeVisitor and will no longer need 
to add application-specific code to the node classes. The Visitor pattern 
encapsulates the operations for each compilation phase in a Visitor associated 
with that phase. With the Visitor pattern, you define two class hierarchies: one for theelements 
being operated on (the Node hierarchy) and one for the visitorsthat define 
operations on the elements (the NodeVisitor hierarchy). Youcreate a new operation 
by adding a new subclass to the visitor classhierarchy. As long as the grammar 
that the compiler accepts doesn'tchange (that is, we don't have to add new Node 
subclasses), we can addnew functionality simply by defining new NodeVisitor 
subclasses. ",,,,,,,,
22,2,"· an object structure contains many classes of objects with differing interfaces, and you want to perform operations on these objects that depend on their concrete classes. · many distinct and unrelated operations need to be performed on objectsin an object structure, and you want to avoid ""polluting"" theirclasses with these operations. Visitor lets you keep related operationstogether by defining them in one class. When the object structure isshared by many applications, use Visitor to put operations in just thoseapplications that need them. · the classes defining the object structure rarely change, but you oftenwant to define new operations over the structure. Changing the objectstructure classes requires redefining the interface to all visitors,which is potentially costly. If the object structure classes changeoften, then it's probably better to define the operations in those classes.",,,,,,,,
22,2,"· Visitor (NodeVisitor) 
o declares a Visit operation for each class of ConcreteElement in the 
object structure. The operation's name and signature identifies the 
class that sends the Visit request to the visitor. That lets the 
visitor determine the concrete class of the element being visited. 
Then the visitor can access the element directly through its 
particular interface. 
· ConcreteVisitor (TypeCheckingVisitor) 
o implements each operation declared by Visitor. Each operation 
implements a fragment of the algorithm defined for the corresponding 
class of object in the structure. ConcreteVisitor provides the 
context for the algorithm and stores its local state. This state 
often accumulates results during the traversal of the structure. 
· Element (Node) 
o defines an Accept operation that takes a visitor as an argument. 
· ConcreteElement (AssignmentNode,VariableRefNode) o implements an Accept operation that takes a visitor as an argument. 
· ObjectStructure (Program) 
o can enumerate its elements. 
o may provide a high-level interface to allow the visitor to visit 
its elements. 
o may either be a composite (see Composite (183)) or a collection such 
as a list or a set. ",,,,,,,,
22,2,"· A client that uses the Visitor pattern must create a ConcreteVisitorobject 
and then traverse the object structure, visiting each elementwith the 
visitor. 
· When an element is visited, it calls the Visitor operation thatcorresponds 
to its class. The element supplies itself as an argumentto this operation 
to let the visitor access its state, if necessary. 
The following interaction diagram illustrates the collaborationsbetween 
an object structure, a visitor, and two elements:",,,,,,,,
22,2,"The Smalltalk-80 compiler has a Visitor class called ProgramNodeEnumerator.It's used primarily for algorithms that analyze source code.It isn't used for code generation or pretty-printing, although it could be. IRIS Inventor is a toolkit for developing 3-D graphics applications. Inventorrepresents a three-dimensional scene as a hierarchy of nodes, eachrepresenting either a geometric object or an attribute of one.Operations like rendering a scene or mapping an input event requiretraversing this hierarchy in different ways. Inventor does thisusing visitors called ""actions."" There are different visitors forrendering, event handling, searching, filing, and determiningbounding boxes. To make adding new nodes easier, Inventor implements adouble-dispatch scheme for C++. The scheme relies on run-time typeinformation and a two-dimensional table in which rows representvisitors and columns represent node classes. The cells store apointer to the function bound to the visitor and node class. Mark Linton coined the term ""Visitor"" in the X Consortium'sFresco Application Toolkit specification.",,,,,,,,
22,2,"Use when you want to separate algorithms from the objects on which they operate, enabling new operations to be added without modifying the objects.",,,,,,,,
22,2,"Separates algorithms from the objects on which they operate, enabling new operations to be added without modifying the objects.",,,,,,,,
22,2,Use when you have a set of objects with different types and want to define new operations on them without modifying their classes.,,,,,,,,
